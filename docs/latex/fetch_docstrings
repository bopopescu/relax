#! /usr/bin/python

###############################################################################
#                                                                             #
# Copyright (C) 2005 Edward d'Auvergne                                        #
#                                                                             #
# This file is part of the program relax.                                     #
#                                                                             #
# relax is free software; you can redistribute it and/or modify               #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# relax is distributed in the hope that it will be useful,                    #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with relax; if not, write to the Free Software                        #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   #
#                                                                             #
###############################################################################




from inspect import formatargspec, getargspec, getdoc
from re import match, search
import sys
from string import lstrip, punctuation, replace, rstrip, split, whitespace

# Add the path to the relax base directory.
sys.path.append(sys.path[0])
sys.path[0] = '../..'

# Import the program relax.
from prompt.interpreter import Interpreter


class Fetch_docstrings:
    def __init__(self):
        """Fetch all the docstrings of the user functions and format them LaTeX style."""

        # Some dummy data structures.
        self.script_file = None
        self.intro_string = ''
        self.dummy_mode = 1

        # Start the interpreter!
        self.interpreter = Interpreter(self)
        self.interpreter.run()

        # Get the blacklisted objects.
        self.get_blacklist()

        # Open the LaTeX file.
        self.file = open('docstring.tex', 'w')

        # Get the names of the data structures.
        names = self.local.keys()

        # Alphabetically sort the names of the data structures.
        names.sort()

        # Loop over the data structures.
        #for name in ['nuclei']:
        for name in names:
            # Skip the name if it is in the blacklist.
            if name in self.blacklist:
                continue

            # Get the object.
            object = self.local[name]

            # Determine if the structure is user function containing class.
            if hasattr(object, '__relax_help__'):
                # Document the user class.
                self.doc_user_class(name, object)

            # Skip the object if there is no docstring.
            if not hasattr(object, '__doc__') or not object.__doc__:
                continue

            # Print the docstring.
            self.print_docstring(name, object)

        # Close the LaTeX file.
        self.file.close()


    def doc_user_class(self, parent_name, parent_object):
        """Document the user class."""

        # Get the names of the data structures.
        names = dir(parent_object)

        # Alphabetically sort the names of the data structures.
        names.sort()

        # Loop over the data structures.
        for name in names:
            # Skip names begining with an underscore.
            if search('^_', name):
                continue

            # Get the object.
            object = getattr(parent_object, name)

            # Skip the object if there is no docstring.
            if not hasattr(object, '__doc__') or not object.__doc__:
                continue

            # Print the docstring.
            self.print_docstring(parent_name + '.' + name, object)


    def format_keywords(self, lines):
        """Change the keyword label to bold sans serif font."""

        # Initialise.
        new_lines = []

        # Loop over the lines to find the examples.
        i = 0
        while 1:
            # No more lines!
            if len(lines) <= i:
                break

            # Start of the example.
            if search(':', lines[i]):
                # Split the line.
                line_elements = split(lines[i], ':')
                if len(line_elements) > 2:
                    sys.write("Keyword failure in: " + `lines[i]` + "\n")
                    sys.exit()

                # Initialise the new keyword line.
                new_lines.append("\n\\keyword{" + line_elements[0] + ":}")
                example_line = line_elements[1]

                # Shift to the next line.
                i = i + 1

                # Find the end of the example.
                while 1:
                    # No more lines!
                    if len(lines) <= i:
                        break

                    # Find the next blank line.
                    if len(lines[i]) == 0:
                        break

                    # Add the line.
                    example_line = example_line + " " + lstrip(lines[i])

                    # Increment the line counter.
                    i = i + 1

                # Append the example line to the new lines.
                new_lines.append(example_line)

            else:
                new_lines.append(lines[i])

            # Increment the line counter.
            i = i + 1

        # Return the lines.
        return new_lines


    def get_blacklist(self):
        """Maintained list of objects in the interpreter namespace which should not be documented."""

        # Initialise the list.
        self.blacklist = []

        # Skip these.
        self.blacklist.append('Numeric')
        self.blacklist.append('pi')
        self.blacklist.append('script')


    def index_entries(self):
        """Function for returning a data structure containing all words which should be indexed."""

        # Initialise.
        index = []

        # The index entries (where to index and the index name).
        index.append('Brownian', 'Brownian diffusion')
        index.append('ellipsoid', 'ellipsoid')
        index.append('Newton', 'Newton minimisation')
        index.append('python', 'Python')

        # Return the index array.
        return index


    def latex_maths(self, string):
        """Function for handling LaTeX maths environments."""

        # Pi.
        string = self.safe_replacement(string, 'pi', '$\pi$')

        # Less than.
        string = replace(string, ' < ', ' $<$ ')

        # Less than or equal.
        string = replace(string, ' <= ', ' $\le$ ')

        # Much less than.
        string = replace(string, ' << ', ' $<<$ ')

        # Greater than.
        string = replace(string, ' > ', ' $>$ ')

        # Greater than or equal.
        string = replace(string, ' >= ', ' $\ge$ ')

        # Much greater than.
        string = replace(string, ' >> ', ' $>>$ ')

        # 1st, 2nd, etc.
        string = replace(string, '1st', '1$^\mathrm{st}$')
        string = replace(string, '2nd', '2$^\mathrm{nd}$')
        string = replace(string, '3rd', '3$^\mathrm{rd}$')
        string = replace(string, '4th', '4$^\mathrm{th}$')
        string = replace(string, '5th', '5$^\mathrm{th}$')
        string = replace(string, '6th', '6$^\mathrm{th}$')
        string = replace(string, '7th', '7$^\mathrm{th}$')
        string = replace(string, '8th', '8$^\mathrm{th}$')
        string = replace(string, '9th', '9$^\mathrm{th}$')
        string = replace(string, '0th', '0$^\mathrm{th}$')
        string = replace(string, '1th', '1$^\mathrm{th}$')
        string = replace(string, '2th', '2$^\mathrm{th}$')
        string = replace(string, '3th', '3$^\mathrm{th}$')


        # Return the new text.
        return string


    def latex_pipeline_initial(self, string):
        """Initial LaTeX conversion pipeline."""

        # Translate to LaTeX quotation marks.
        string = self.latex_quotes(string)

        # Prefix the backslash to the special LaTeX characters.
        string = self.latex_special_chars(string)

        # Return the LaTeX string.
        return string


    def latex_pipeline_final(self, string):
        """Final LaTeX conversion pipeline."""

        # Skip the newly created environments.
        ######################################

        # The example environment.
        if search('example{', string):
            return string

        # The keyword environment.
        if search('keyword{', string):
            return string

        # The Quote environment.
        if search('quoteenv{', string):
            return string


        # LaTeX maths.
        string = self.latex_maths(string)

        # Model-free parameters.
        string = self.parameter_replement(string)

        # Return the LaTeX string.
        return string


    def latex_quotes(self, string):
        """Function for changing the quotes for LaTeX processing."""

        # Initialise.
        new_string = ''
        in_quote = 0

        # Loop over the characters.
        for i in xrange(len(string)):
            # Find the quote marks.
            if search('\'', string[i]):
                # Swap the opening ' with `.
                if not in_quote and (i == 0 or not search('[a-z]', string[i-1])):
                    new_string = new_string + '`'
                    in_quote = 1
                    continue

                # Just exited the quote
                else:
                    in_quote = 0

            # Append the character.
            new_string = new_string + string[i]

        return new_string


    def latex_special_chars(self, string):
        """Function for handling LaTeX special characters."""

        # Damned backslashes.
        string = replace(string, '\\', 'This is a backslash to be replaced at the end of this functioN')

        # List of special characters (prefix a backslash).
        for char in "#$%&_{}":
            string = replace(string, char, '\\'+char)

        # Doubly special characters (prefix a backslash and postfix '{}').
        for char in "^~":
            string = replace(string, char, '\\'+char+'{}')

        # Damned backslashes!
        string = replace(string, 'This is a backslash to be replaced at the end of this functioN', '$\\backslash$')

        # Return the new text.
        return string


    def lists(self, lines):
        """Function for creating LaTeX lists."""

        # Find the start, end, type, and element spacing of each list.
        ##############################################################

        # Initialise.
        list_start = []
        list_end = []
        list_type = []
        list_spacing = []
        in_list = 0
        in_table = 0

        # Walk over the lines.
        for i in xrange(len(lines)):
            # Inside a table.
            if search('begin{tabular}', lines[i]):
                in_table = 1

            # Out of the table.
            if search('end{tabular}', lines[i]):
                in_table = 0

            # Match to the start of a list (not within a table).
            if not in_list and search('^ ', lines[i]) and not in_table:
                # Start of the list.
                list_start.append(i)

                # Determine the type of list.
                elements = split(lines[i], ':')

                # Badly formatted list.
                if len(elements) > 2:
                    sys.stdout.write("Error: Badly formatted list element.\n")
                    sys.stdout.write("The element is: " + `lines[i]` + "\n")
                    sys.exit()

                # Plain list.
                if len(elements) == 1:
                    list_type.append(0)

                # Formatted list.
                else:
                    list_type.append(1)

                # Determine the element spacing.
                j = i
                while 1:
                    # Walk to the next line.
                    j = j + 1

                    # No more lines.
                    if len(lines) <= j:
                        list_spacing.append(0)
                        break

                    # Find the empty line.
                    if len(lines[j]) == 0:
                        # No more lines.
                        if len(lines) <= j+1:
                            list_spacing.append(0)

                        # Determine if the next line is an element of the list.
                        elif search('^ ', lines[j+1]):
                            list_spacing.append(1)

                        # or not.
                        else:
                            list_spacing.append(0)

                        break
                
                # Now within the list.
                in_list = 1

            # Match to the end of a list.
            if in_list and len(lines[i]) == 0 and list_spacing[-1] == 0:
                # End of the list.
                list_end.append(i)

                # Now out of the list.
                in_list = 0

            # Match to the end of a list.
            if in_list and (search('^[A-Z]', lines[i]) or search('^[a-z]', lines[i])):
                # End of the list.
                list_end.append(i)

                # Now out of the list.
                in_list = 0

        # The list terminates on the last line.
        if len(list_start) != len(list_end):
            list_end.append(len(lines))


        # LaTeX list formatting.
        ########################

        # Initialise.
        new_lines = []
        in_list = 0
        num = None

        # Walk over the lines.
        for i in xrange(len(lines)):
            # Start of the list.
            if i in list_start:
                # Inside the list.
                in_list = 1

                # The list number.
                num = list_start.index(i)

                # Start the list.
                if list_type[num] == 1:
                    new_lines.append("\\begin{description}")
                else:
                    new_lines.append("\\begin{itemize}")

            # End of the list.
            if in_list and i == list_end[num]:
                # Out of the list.
                in_list = 0

                # End of the list.
                if list_type[num] == 1:
                    new_lines.append("\\end{description}")
                else:
                    new_lines.append("\\end{itemize}")

            # List items.
            if in_list:
                # Spaced lists.
                if list_spacing[num]:
                    # Determine if the current line is the start of a list element.
                    if len(lines[i-1]) == 0:
                        # Plain list.
                        if list_type[num] == 0:
                            new_lines.append("\\item[] " + lines[i])

                        # Description.
                        else:
                            # Get the description.
                            elements = split(lines[i], ':')

                            # Format the element.
                            new_lines.append("\\item[" + elements[0] + ":] " + elements[1])

                    # Otherwise add it to the last line.
                    else:
                        new_lines[-1] = new_lines[-1] + " " + lstrip(lines[i])

                # Non-spaced lists.
                else:
                    # Plain list.
                    if list_type[num] == 0:
                        new_lines.append("\\item[] " + lines[i])

                    # Description.
                    else:
                        # Get the description.
                        elements = split(lines[i], ':')

                        # Format the element.
                        new_lines.append("\\item[" + elements[0] + ":] " + elements[1])


            # Non-list lines.
            else:
                new_lines.append(lines[i])

        # The list terminates on the last line.
        if len(list_end) and list_end[-1] == len(lines):
            # End of the list.
            if list_type[num] == 1:
                new_lines.append("\\end{description}")
            else:
                new_lines.append("\\end{itemize}")


        # Return the formatted lines.
        return new_lines



    def parameter_replement(self, string):
        """Function for LaTeXing special parameter names."""

        # Model-free parameters.
        ########################

        # S2f.
        string = self.safe_replacement(string, 'S2f', '$S^2_f$')

        # S2s.
        string = self.safe_replacement(string, 'S2s', '$S^2_s$')

        # S2.
        string = self.safe_replacement(string, 'S2', '$S^2$')

        # te.
        string = self.safe_replacement(string, 'te', '$\\tau_e$')

        # ts.
        string = self.safe_replacement(string, 'ts', '$\\tau_s$')

        # tf.
        string = self.safe_replacement(string, 'tf', '$\\tau_f$')

        # tm.
        string = self.safe_replacement(string, 'tm', '$\\tau_m$')

        # Rex.
        string = self.safe_replacement(string, 'Rex', '$R_{ex}$')

        # CSA.
        string = self.safe_replacement(string, 'CSA', '$CSA$')

        # r.
        string = self.safe_replacement(string, 'r', '$r$')
        string = self.safe_replacement(string, '<r>', '$<$$r$$>$')


        # Diffusion tensor parameters.
        ##############################

        # Diso.
        string = self.safe_replacement(string, 'Diso', '$\Diff_{iso}$')

        # Da.
        string = self.safe_replacement(string, 'Da', '$\Diff_a$')

        # Dr.
        string = self.safe_replacement(string, 'Dr', '$\Diff_r$')

        # Dx.
        string = self.safe_replacement(string, 'Dx', '$\Diff_x$')

        # Dy.
        string = self.safe_replacement(string, 'Dy', '$\Diff_y$')

        # Dz.
        string = self.safe_replacement(string, 'Dz', '$\Diff_z$')

        # Dpar.
        string = self.safe_replacement(string, 'Dpar', '$\Diff_\Par$')

        # Dper.
        string = self.safe_replacement(string, 'Dper', '$\Diff_\Per$')

        # Dratio.
        string = self.safe_replacement(string, 'Dratio', '$\Diff_{ratio}$')

        # alpha.
        string = self.safe_replacement(string, 'alpha', '$\\alpha$')

        # beta.
        string = self.safe_replacement(string, 'beta', '$\\beta$')

        # gamma.
        string = self.safe_replacement(string, 'gamma', '$\\gamma$')

        # theta.
        string = self.safe_replacement(string, 'theta', '$\\theta$')

        # phi.
        string = self.safe_replacement(string, 'phi', '$\\phi$')


        # Indecies.
        ###########

        # i.
        string = self.safe_replacement(string, 'i', '$i$')

        # j.
        string = self.safe_replacement(string, 'j', '$j$')

        # k.
        string = self.safe_replacement(string, 'k', '$k$')

        # l.
        string = self.safe_replacement(string, 'l', '$l$')

        # m.
        string = self.safe_replacement(string, 'm', '$m$')

        # n.
        string = self.safe_replacement(string, 'n', '$n$')

        # x.
        string = self.safe_replacement(string, 'x', '$x$')

        # y.
        string = self.safe_replacement(string, 'y', '$y$')

        # z.
        string = self.safe_replacement(string, 'z', '$z$')


        # Return the new text.
        return string


    def print_docstring(self, function, object):
        """Function for creating the LaTeX file."""

        # Initialise.
        #############

        # Print the function name to sys.stdout
        sys.stdout.write("Function: " + `function` + "\n")

        # Comment out underscores in the function name.
        function_name = self.latex_pipeline_initial(function)

        # Get the docstring.
        docstring = getdoc(object)

        # Split the docstring by newline characters.
        self.docstring_lines = split(docstring, "\n")

        # Strip any whitespace from the end of the line.
        for i in xrange(len(self.docstring_lines)):
            self.docstring_lines[i] = rstrip(self.docstring_lines[i])


        # Subsection.
        #############

        # Start a new page.
        self.file.write("\n\n\\newpage")

        # Write the function name.
        self.file.write("\n\n\subsection{" + function_name + "}\n\n")


        # Synopsis.
        ###########

        # Heading.
        self.file.write("\n\\subsubsection{Synopsis}\n\n")

        # Write the synopsis.
        synopsis = self.latex_pipeline_initial(self.docstring_lines[0])
        synopsis = self.latex_pipeline_final(synopsis)
        self.file.write(synopsis + "\n")


        # Arguments.
        ############

        # Heading.
        self.file.write("\n\\subsubsection{Defaults}\n\n")

        # Typewriter font.
        self.file.write("\\textsf{")

        # Function name.
        self.file.write("\\textbf{" + function_name + "}")

        # Get the arguments.
        args, varargs, varkw, defaults = getargspec(object)

        # Argument string.
        arguments = formatargspec(args, varargs, varkw, defaults)

        # Write the synopsis.
        self.file.write(self.latex_pipeline_initial(arguments))

        # End typewriter font.
        self.file.write("}\n\n")


        # Docstring processing.
        #######################

        # Find the section positions.
        self.section_positions()

        # Loop over the docstring sections.
        for i in xrange(len(self.section_start)):
            # Title.
            self.section_title = self.docstring_lines[self.section_start[i]]

            # Subsubsectioning.
            self.file.write("\n\\subsubsection{" + self.section_title + "}\n\n")

            # Pull out the section lines (skip the title line, tilde line, and first blank line).
            lines = self.docstring_lines[self.section_start[i]+3:self.section_end[i]]

            # Initial LaTeX conversion pipeline.
            for j in xrange(len(lines)):
                lines[j] = self.latex_pipeline_initial(lines[j])

            # Format the 'Keyword Arguements' section.
            if search('^Keyword ', self.section_title):
                lines = self.format_keywords(lines)

            # All other sections.
            else:
                # Tables.
                lines = self.tables(lines)

                # relax> or '$ ...' example lines.
                lines = self.relax_examples(lines)

                # Lists.
                lines = self.lists(lines)

            # Place quotes in the \quoteenv environment.
            lines = self.quote_environ(lines)

            # Final LaTeX conversion pipeline.
            for j in xrange(len(lines)):
                lines[j] = self.latex_pipeline_final(lines[j])

            # Loop over the section line by line and write them.
            for line in lines:
                self.file.write(line + "\n")


    def quote_environ(self, lines):
        """Function for placing quotes within the quote environment."""

        # Initialise.
        new_lines = []

        # Loop over the lines.
        for line in lines:
            # Skip the newly created environments.
            ######################################

            # The example environment.
            if search('example{', line):
                new_lines.append(line)
                continue

            # The keyword environment.
            if search('keyword{', line):
                new_lines.append(line)
                continue


            # Initialise.
            new_string = ''
            in_quote = 0
            just_exited = 0

            # Loop over the characters.
            for i in xrange(len(line)):
                # Find the start of the quote (when not already inside a quote).
                if search('`', line[i]) and not in_quote:
                    if not new_string == '':
                        new_lines.append(new_string)
                        new_string = ''
                    new_string = '\quoteenv{'
                    in_quote = 1

                # Find the end of the quote.
                elif search('\'', line[i]) and in_quote:
                    # Just exited the quote
                    just_exited = 1
                    in_quote = 0

                # Append the character.
                new_string = new_string + line[i]

                # Close the quote environent and start a new string.
                if just_exited:
                    new_string = new_string + '}'
                    new_lines.append(new_string)
                    new_string = ''
                    just_exited = 0

            # Append the new string.
            new_lines.append(new_string)

        # Return the lines
        return new_lines


    def relax_examples(self, lines):
        """Use typewriter font for relax examples."""

        # Initialise.
        new_lines = []

        # Loop over the lines to find the examples.
        i = -1
        while 1:
            # Increment the line counter.
            i = i + 1

            # No more lines!
            if len(lines) <= i:
                break

            # Start of the example.
            if search('^relax>', lines[i]) or search('^\\\\\$ ', lines[i]):
                # Initialise the new example line.
                example_line = "\\example{"

                # Find the end of the example.
                while 1:
                    # Add the line.
                    example_line = example_line + lstrip(lines[i]) + " "

                    # No more lines!
                    if len(lines) <= i+1:
                        break

                    # Find the next example or blank line.
                    if search('^relax>', lines[i+1]) or search('^\\\\\$ ', lines[i+1]) or len(lines[i+1]) == 0:
                        break

                    # Shift to the next line.
                    i = i + 1

                # Terminate the example line.
                example_line = example_line + "}\n"

                # Append the example line to the new lines.
                new_lines.append(example_line)

            else:
                new_lines.append(lines[i])

        # Return the lines.
        return new_lines


    def safe_replacement(self, string, text, latex):
        """Only replace in safe places within the text."""

        # Combos (if only RE could be used!)

        # A number out the front.
        string = replace(string,    '0'+text,           '0'+latex)
        string = replace(string,    '1'+text,           '1'+latex)
        string = replace(string,    '2'+text,           '2'+latex)
        string = replace(string,    '3'+text,           '3'+latex)
        string = replace(string,    '4'+text,           '4'+latex)
        string = replace(string,    '5'+text,           '5'+latex)
        string = replace(string,    '6'+text,           '6'+latex)
        string = replace(string,    '7'+text,           '7'+latex)
        string = replace(string,    '8'+text,           '8'+latex)
        string = replace(string,    '9'+text,           '9'+latex)

        # In a sentence.
        string = replace(string,    ' '+text+',',       ' '+latex+',')
        string = replace(string,    ' '+text+'.',       ' '+latex+'.')
        string = replace(string,    ' '+text+' ',       ' '+latex+' ')
        string = replace(string,    ' '+text+';',       ' '+latex+';')
        string = replace(string,    ' '+text+':',       ' '+latex+':')

        # In lists [].
        string = replace(string,    '['+text+']',       '['+latex+']')
        string = replace(string,    '['+text+' ',       '['+latex+' ')
        string = replace(string,    '['+text+',',       '['+latex+',')
        string = replace(string,    '['+text+';',       '['+latex+';')
        string = replace(string,    ' '+text+']',       ' '+latex+']')

        # In lists ().
        string = replace(string,    '('+text+')',       '('+latex+')')
        string = replace(string,    '('+text+' ',       '('+latex+' ')
        string = replace(string,    '('+text+',',       '('+latex+',')
        string = replace(string,    '('+text+';',       '('+latex+';')
        string = replace(string,    ' '+text+')',       ' '+latex+')')

        # In lists {}.
        string = replace(string,    '{'+text+' ',       '{'+latex+' ')
        string = replace(string,    '{'+text+',',       '{'+latex+',')
        string = replace(string,    '{'+text+';',       '{'+latex+';')
        string = replace(string,    ' '+text+'\\',      ' '+latex+'\\')

        # Quoted.
        string = replace(string,    '`'+text+'\'',      '`'+latex+'\'')
        string = replace(string,    '`'+text+' ',       '`'+latex+' ')
        string = replace(string,    '`'+text+',',       '`'+latex+',')
        string = replace(string,    '`'+text+'.',       '`'+latex+'.')
        string = replace(string,    '`'+text+';',       '`'+latex+';')
        string = replace(string,    ' '+text+'\'',      ' '+latex+'\'')

        # End of the line.
        substring = replace(string[-len(text)-1:],    ' '+text,      ' '+latex)
        string = string[0:-len(text)-1] + substring

        substring = replace(string[-len(text)-1:],    '.'+text,      '.'+latex)
        string = string[0:-len(text)-1] + substring

        string = replace(string,    ' '+text+'\n',      ' '+latex+'\n')
        string = replace(string,    '.'+text+'\n',      '.'+latex+'\n')

        # In equation.
        string = replace(string,    '*'+text,           '*'+latex)
        string = replace(string,    text+'*',           latex+'*')

        # At the start of the line.
        if search('^'+text+'['+punctuation+']', string) or search('^'+text+'['+whitespace+']', string):
            string = replace(string,    text+' ',           latex+' ')
            string = replace(string,    text+',',           latex+',')
            string = replace(string,    text+'.',           latex+'.')
            string = replace(string,    text+':',           latex+':')
            string = replace(string,    text+';',           latex+';')
            string = replace(string,    text+']',           latex+']')
            string = replace(string,    text+')',           latex+')')
            string = replace(string,    text+'\\',          latex+'\\')
            string = replace(string,    text+'\'',          latex+'\'')
            string = replace(string,    text+'\n',          latex+'\n')


        # Return the string.
        return string


    def section_positions(self):
        """Find the positions of the docstring titles."""

        # Initialise.
        self.section_start = []
        self.section_end = []

        # Find the start of the sections.
        for i in xrange(len(self.docstring_lines)):
            # Find the tilde lines.
            if search('^~.*~$', self.docstring_lines[i]):
                # The title position is the previous line.
                self.section_start.append(i-1)

        # Loop over the sections.
        for i in xrange(len(self.section_start)):
            # Find the end of the section.
            try:
                # One line before the next section.
                self.section_end.append(self.section_start[i+1]-1)
            except:
                # End of the docstring.
                self.section_end.append(len(self.docstring_lines))

            # Strip the empty lines at the end away (walking backwards).
            for j in range(self.section_end[i], self.section_start[i]):
                # If the last line is blank, decrease the section end position by one.
                if len(self.docstring_lines[j]) == 0:
                    self.section_end[i] = self.section_end[i] - 1


    def tables(self, lines):
        """Function for creating LaTeX tables."""

        # Initialise.
        new_lines = []

        # Loop over the lines to find the examples.
        i = -1
        while 1:
            # Increment the line counter.
            i = i + 1

            # No more lines!
            if len(lines) <= i:
                break

            # Start of the table.
            if search('^\\\\_.*\\\\_$', lines[i]):
                # Shift to the next line.
                i = i + 1

                # Count the number of columns.
                num_col = len(split(lines[i], '|'))

                # Not really a table!
                if num_col == 1:
                    new_lines.append(lines[i])
                    continue

                # Add an empty line.
                new_lines.append('\n')

                # Start the table and center it.
                new_lines.append("\\begin{center}")
                new_lines.append("\\begin{tabular}{" + (num_col-2)*"l" + "}")

                # Add the toprule.
                new_lines.append("\\toprule\n")

                # Shift to the next line.
                i = i + 1

                # Get the headings.
                headings = split(lines[i], '|')
                headings = headings[1:-1]
                for j in xrange(len(headings)):
                    headings[j] = lstrip(rstrip(headings[j]))

                # Generate the LaTeX headings.
                string = headings[0]
                for j in range(1, len(headings)):
                    string = string + " & " + headings[j]
                new_lines.append(string + " \\\\\n")

                # Add the midrule.
                new_lines.append("\\midrule\n")

                # Skip three lines.
                i = i + 3

                # Go through the table.
                while 1:
                    # No more lines!
                    if len(lines) <= i:
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Find the end of the table.
                    if search('^\\|\\\\_', lines[i]):
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Split the columns.
                    columns = split(lines[i], '|')

                    # Create the formatted tabular line.
                    if len(columns) > 1:
                        string = lstrip(rstrip(columns[1]))
                        for j in range(2, len(columns)-1):
                            string = string + " & " + lstrip(rstrip(columns[j]))
                        string = string + " \\\\\n"
                    else:
                        string = columns[0] + " \\\\\n"

                    # Add the line.
                    new_lines.append(string)

                    # Increment the line counter.
                    i = i + 1

                # Add the bottomrule.
                new_lines.append("\\bottomrule\n")

                # Terminate the tabular and center environment.
                new_lines.append("\\end{tabular}")
                new_lines.append("\\end{center}\n")

            else:
                new_lines.append(lines[i])

        # Return the lines.
        return new_lines



if __name__ == '__main__':
    Fetch_docstrings()
