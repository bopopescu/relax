#! /usr/bin/python

from inspect import formatargspec, getargspec, getdoc
from re import search
import sys
from string import lstrip, replace, rstrip, split

# Add the path to the relax base directory.
sys.path.append(sys.path[0])
sys.path[0] = '../..'

# Import the program relax.
from prompt.interpreter import Interpreter


class Fetch_docstrings:
    def __init__(self):
        """Fetch all the docstrings of the user functions and format them LaTeX style."""

        # Some dummy data structures.
        self.script_file = None
        self.intro_string = ''
        self.dummy_mode = 1

        # Start the interpreter!
        self.interpreter = Interpreter(self)
        self.interpreter.run()

        # Get the blacklisted objects.
        self.get_blacklist()

        # Open the LaTeX file.
        self.file = open('docstring.tex', 'w')

        # Get the names of the data structures.
        names = self.local.keys()

        # Alphabetically sort the names of the data structures.
        names.sort()

        # Loop over the data structures.
        for name in names:
            # Skip the name if it is in the blacklist.
            if name in self.blacklist:
                continue

            # Get the object.
            object = self.local[name]

            # Determine if the structure is user function containing class.
            if hasattr(object, '__relax_help__'):
                # Document the user class.
                self.doc_user_class(name, object)

            # Skip the object if there is no docstring.
            if not hasattr(object, '__doc__') or not object.__doc__:
                continue

            # Print the docstring.
            self.print_docstring(name, object)

        # Close the LaTeX file.
        self.file.close()


    def doc_user_class(self, parent_name, parent_object):
        """Document the user class."""

        # Get the names of the data structures.
        names = dir(parent_object)

        # Alphabetically sort the names of the data structures.
        names.sort()

        # Loop over the data structures.
        for name in names:
            # Skip names begining with an underscore.
            if search('^_', name):
                continue

            # Get the object.
            object = getattr(parent_object, name)

            # Skip the object if there is no docstring.
            if not hasattr(object, '__doc__') or not object.__doc__:
                continue

            # Print the docstring.
            self.print_docstring(parent_name + '.' + name, object)


    def format_keywords(self, lines):
        """Change the keyword label to bold sans serif font."""

        # Initialise.
        new_lines = []

        # Loop over the lines to find the examples.
        i = 0
        while 1:
            # No more lines!
            if len(lines) <= i:
                break

            # Start of the example.
            if search(':', lines[i]):
                # Split the line.
                line_elements = split(lines[i], ':')
                if len(line_elements) > 2:
                    sys.write("Keyword failure in: " + `lines[i]` + "\n")
                    sys.exit()

                # Initialise the new keyword line.
                example_line = "\\keyword{" + line_elements[0] + ":}" + line_elements[1]

                # Shift to the next line.
                i = i + 1

                # Find the end of the example.
                while 1:
                    # No more lines!
                    if len(lines) <= i:
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Find the next blank line.
                    if len(lines[i]) == 0:
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Add the line.
                    example_line = example_line + " " + lstrip(lines[i])

                    # Increment the line counter.
                    i = i + 1

                # Append the example line to the new lines.
                new_lines.append(example_line)

            else:
                new_lines.append(lines[i])

            # Increment the line counter.
            i = i + 1

        # Return the lines.
        return new_lines


    def get_blacklist(self):
        """Maintained list of objects in the interpreter namespace which should not be documented."""

        # Initialise the list.
        self.blacklist = []

        # Skip these.
        self.blacklist.append('Numeric')
        self.blacklist.append('pi')
        self.blacklist.append('script')


    def latex_maths(self, string):
        """Function for handling LaTeX maths environments."""

        # Less than.
        string = replace(string, ' < ', ' $<$ ')

        # Less than or equal.
        string = replace(string, ' <= ', ' $<=$ ')

        # Much less than.
        string = replace(string, ' << ', ' $<<$ ')

        # Greater than.
        string = replace(string, ' > ', ' $>$ ')

        # Greater than or equal.
        string = replace(string, ' >= ', ' $>=$ ')

        # Much greater than.
        string = replace(string, ' >> ', ' $>>$ ')

        # A specific example.
        string = replace(string, '<r>', '$<$r$>$')

        # Return the new text.
        return string


    def latex_pipeline(self, string):
        """This will process the given string and return a new string properly formatted for LaTeX."""

        # Translate to LaTeX quotation marks.
        string = self.latex_quotes(string)

        # Prefix the backslash to the special LaTeX characters.
        string = self.latex_special_chars(string)

        # Return the LaTeX string.
        return string


    def latex_quotes(self, string):
        """Function for changing the quotes for LaTeX processing."""

        # Initialise.
        new_string = ''
        in_quote = 0

        # Loop over the characters.
        for i in xrange(len(string)):
            # Find the quote marks.
            if search('\'', string[i]):
                # Swap the opening ' with `.
                if not in_quote:
                    new_string = new_string + '`'
                    in_quote = 1
                    continue

                # Just exited the quote
                else:
                    in_quote = 0

            # Append the character.
            new_string = new_string + string[i]

        return new_string


    def latex_special_chars(self, string):
        """Function for handling LaTeX special characters."""

        # Damned backslashes.
        string = replace(string, '\\', 'This is a backslash to be replaced at the end of this functioN')

        # List of special characters (prefix a backslash).
        for char in "#$%&_{}":
            string = replace(string, char, '\\'+char)

        # Doubly special characters (prefix a backslash and postfix '{}').
        for char in "^~":
            string = replace(string, char, '\\'+char+'{}')

        # Damned backslashes!
        string = replace(string, 'This is a backslash to be replaced at the end of this functioN', '$\\backslash$')

        # Return the new text.
        return string


    def print_docstring(self, function, object):
        """Function for creating the LaTeX file."""

        # Initialise.
        #############

        # Comment out underscores in the function name.
        function_name = self.latex_pipeline(function)

        # Get the docstring.
        docstring = getdoc(object)

        # Split the docstring by newline characters.
        self.docstring_lines = split(docstring, "\n")

        # Strip any whitespace from the end of the line.
        for i in xrange(len(self.docstring_lines)):
            self.docstring_lines[i] = rstrip(self.docstring_lines[i])


        # Subsection.
        #############

        # Start a new page.
        self.file.write("\n\n\\newpage")

        # Write the function name.
        self.file.write("\n\n\subsection{" + function_name + "}\n\n")


        # Synopsis.
        ###########

        # Heading.
        self.file.write("\n\\subsubsection{Synopsis}\n\n")

        # Write the synopsis.
        self.file.write(self.latex_pipeline(self.docstring_lines[0]) + "\n")


        # Arguments.
        ############

        # Heading.
        self.file.write("\n\\subsubsection{Default arguments}\n\n")

        # Typewriter font.
        self.file.write("\\textsf{")

        # Function name.
        self.file.write("\\textbf{" + function_name + "}")

        # Get the arguments.
        args, varargs, varkw, defaults = getargspec(object)

        # Argument string.
        arguments = formatargspec(args, varargs, varkw, defaults)

        # Write the synopsis.
        self.file.write(self.latex_pipeline(arguments))

        # End typewriter font.
        self.file.write("}\n\n")


        # Docstring processing.
        #######################

        # Find the section positions.
        self.section_positions()

        # Loop over the docstring sections.
        for i in xrange(len(self.section_start)):
            # Title.
            self.section_title = self.docstring_lines[self.section_start[i]]

            # Subsubsectioning.
            self.file.write("\n\\subsubsection{" + self.section_title + "}\n\n")

            # Pull out the section lines (skip the title line, tilde line, and first blank line).
            lines = self.docstring_lines[self.section_start[i]+3:self.section_end[i]]

            # Loop over the section line by line and translate to LaTeX text.
            for j in xrange(len(lines)):
                lines[j] = self.latex_pipeline(lines[j])

            # Format the 'Keyword Arguements' section.
            if search('^Keyword ', self.section_title):
                lines = self.format_keywords(lines)

            # All other sections.
            else:
                # Tables.
                lines = self.tables(lines)

                # relax> example lines.
                lines = self.relax_examples(lines)

            # Maths (must be dead last).
            for j in xrange(len(lines)):
                lines[j] = self.latex_maths(lines[j])

            # Loop over the section line by line and write them.
            for line in lines:
                self.file.write(line + "\n")


    def relax_examples(self, lines):
        """Use typewriter font for relax examples."""

        # Initialise.
        new_lines = []

        # Loop over the lines to find the examples.
        i = 0
        while 1:
            # No more lines!
            if len(lines) <= i:
                break

            # Start of the example.
            if search('^relax>', lines[i]):
                # Initialise the new example line.
                example_line = "\\example{" + lines[i]

                # Shift to the next line.
                i = i + 1

                # Find the end of the example.
                while 1:
                    # No more lines!
                    if len(lines) <= i:
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Find the next example or blank line.
                    if search('^relax>', lines[i]) or len(lines[i]) == 0:
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Add the line.
                    example_line = example_line + " " + lstrip(lines[i])

                    # Increment the line counter.
                    i = i + 1

                # Terminate the example line.
                example_line = example_line + "}\n"

                # Append the example line to the new lines.
                new_lines.append(example_line)

            else:
                new_lines.append(lines[i])

            # Increment the line counter.
            i = i + 1

        # Return the lines.
        return new_lines


    def section_positions(self):
        """Find the positions of the docstring titles."""

        # Initialise.
        self.section_start = []
        self.section_end = []

        # Find the start of the sections.
        for i in xrange(len(self.docstring_lines)):
            # Find the tilde lines.
            if search('^~.*~$', self.docstring_lines[i]):
                # The title position is the previous line.
                self.section_start.append(i-1)

        # Loop over the sections.
        for i in xrange(len(self.section_start)):
            # Find the end of the section.
            try:
                # One line before the next section.
                self.section_end.append(self.section_start[i+1]-1)
            except:
                # End of the docstring.
                self.section_end.append(len(self.docstring_lines))

            # Strip the empty lines at the end away (walking backwards).
            for j in range(self.section_end[i], self.section_start[i]):
                # If the last line is blank, decrease the section end position by one.
                if len(self.docstring_lines[j]) == 0:
                    self.section_end[i] = self.section_end[i] - 1


    def tables(self, lines):
        """Function for creating LaTeX tables."""

        # Initialise.
        new_lines = []

        # Loop over the lines to find the examples.
        i = -1
        while 1:
            # Increment the line counter.
            i = i + 1

            # No more lines!
            if len(lines) <= i:
                break

            # Start of the table.
            if search('^\\\\_.*\\\\_$', lines[i]):
                # Shift to the next line.
                i = i + 1

                # Count the number of columns.
                num_col = len(split(lines[i], '|'))

                # Not really a table!
                if num_col == 1:
                    new_lines.append(lines[i])
                    continue

                # Add an empty line.
                new_lines.append('\n')

                # Start the table and center it.
                new_lines.append("\\begin{center}")
                new_lines.append("\\begin{tabular}{" + (num_col-2)*"l" + "}")

                # Add the toprule.
                new_lines.append("\\toprule")

                # Shift to the next line.
                i = i + 1

                # Get the headings.
                headings = split(lines[i], '|')
                headings = headings[1:-1]
                for j in xrange(len(headings)):
                    headings[j] = lstrip(rstrip(headings[j]))

                # Generate the LaTeX headings.
                string = headings[0]
                for j in range(1, len(headings)):
                    string = string + " & " + headings[j]
                new_lines.append(string + " \\\\")

                # Add the midrule.
                new_lines.append("\\midrule")

                # Skip three lines.
                i = i + 3

                # Go through the table.
                while 1:
                    # No more lines!
                    if len(lines) <= i:
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Find the end of the table.
                    if search('^\\|\\\\_', lines[i]):
                        # Increment the line counter then break.
                        i = i + 1
                        break

                    # Split the columns.
                    columns = split(lines[i], '|')

                    # Create the formatted tabular line.
                    if len(columns) > 1:
                        string = columns[1]
                        for j in range(2, len(columns)-1):
                            string = string + " & " + columns[j]
                        string = string + " \\\\"
                    else:
                        string = columns[0] + " \\\\"

                    # Add the line.
                    new_lines.append(string)

                    # Increment the line counter.
                    i = i + 1

                # Add the bottomrule.
                new_lines.append("\\bottomrule")

                # Terminate the tabular and center environment.
                new_lines.append("\\end{tabular}")
                new_lines.append("\\end{center}\n")

            else:
                new_lines.append(lines[i])

        # Return the lines.
        return new_lines



if __name__ == '__main__':
    Fetch_docstrings()
