

\newpage

\subsection{angles\index{angles|textbf}}


\subsubsection{Synopsis}

Function for calculating the angles\index{angles} between the XH bond vector and the diffusion tensor.\index{diffusion!tensor}



\subsubsection{Defaults}

\textsf{\textbf{angles}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Description}

If the diffusion tensor\index{diffusion!tensor} is isotropic\index{diffusion!sphere (isotropic)} for the run, then nothing will be done.


If the diffusion tensor\index{diffusion!tensor} is axially symmetric,\index{diffusion!spheroid (axially symmetric)} then the angle\index{angles} $\alpha$ will be calculated for each XH bond vector.


If the diffusion tensor\index{diffusion!tensor} is asymmetric,\index{diffusion!ellipsoid (asymmetric)} then the three angles\index{angles} will be calculated.




\newpage

\subsection{calc}


\subsubsection{Synopsis}

Function for calculating the function value.



\subsubsection{Defaults}

\textsf{\textbf{calc}(self, run=None, print\_flag=1)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 





\newpage

\subsection{diffusion\_tensor.copy}


\subsubsection{Synopsis}

Function for copying\index{copy} diffusion tensor\index{diffusion!tensor} data from run1 to run2.



\subsubsection{Defaults}

\textsf{\textbf{diffusion\_tensor.copy}(self, run1=None, run2=None)}


\subsubsection{Keyword Arguments}

\keyword{run1:}  The name of the run to copy\index{copy} the sequence\index{sequence} from. 

\keyword{run2:}  The name of the run to copy\index{copy} the sequence\index{sequence} to. 




\subsubsection{Description}

This function will copy\index{copy} the diffusion tensor\index{diffusion!tensor} data from \quotecmd{run1} to \quotecmd{run2}.  \quotecmd{run2} must not contain any diffusion tensor\index{diffusion!tensor} data.



\subsubsection{Examples}

To copy\index{copy} the diffusion tensor\index{diffusion!tensor} from run \quotecmd{m1} to run \quotecmd{m2}, type:


\example{relax> diffusion\_tensor.copy(`m1', `m2')}



\newpage

\subsection{diffusion\_tensor.delete}


\subsubsection{Synopsis}

Function for deleting diffusion tensor\index{diffusion!tensor} data.



\subsubsection{Defaults}

\textsf{\textbf{diffusion\_tensor.delete}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Description}

This function will delete\index{delete} all diffusion tensor\index{diffusion!tensor} data for the given run.




\newpage

\subsection{diffusion\_tensor.display}


\subsubsection{Synopsis}

Function for displaying\index{display} the diffusion tensor.\index{diffusion!tensor}



\subsubsection{Defaults}

\textsf{\textbf{diffusion\_tensor.display}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 





\newpage

\subsection{diffusion\_tensor.set}


\subsubsection{Synopsis}

Function for setting up the diffusion tensor.\index{diffusion!tensor}



\subsubsection{Defaults}

\textsf{\textbf{diffusion\_tensor.set}(self, run=None, params=None, time\_scale=1.0, d\_scale=1.0, angle\_units=`deg', param\_types=0, spheroid\_type=None, fixed=1)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run to assign the data to. 

\keyword{params:}  The diffusion tensor\index{diffusion!tensor} data. 

\keyword{time\_scale:}  The correlation time\index{correlation time} scaling value. 

\keyword{d\_scale:}  The diffusion tensor\index{diffusion!tensor} eigenvalue\index{eigenvalues} scaling value. 

\keyword{angle\_units:}  The units for the angle\index{angles} parameters. 

\keyword{param\_types:}  A flag to select different parameter combinations. 

\keyword{spheroid\_type:}  A string which, if supplied together with spheroid\index{diffusion!spheroid (axially symmetric)} parameters, will restrict the tensor to either being \quotecmd{oblate} or \quotecmd{prolate}. 

\keyword{fixed:}  A flag specifying whether the diffusion tensor\index{diffusion!tensor} is fixed or can be optimised.\index{optimise} 




\subsubsection{The sphere\index{diffusion!sphere (isotropic)|textbf} (isotropic diffusion)}

When the molecule\index{molecule} diffuses as a sphere,\index{diffusion!sphere (isotropic)} all three eigenvalues\index{eigenvalues} of the diffusion tensor\index{diffusion!tensor} are equal, $\Diff_x$ = $\Diff_y$ = $\Diff_z$.  In this case, the orientation of the XH bond vector within the diffusion frame is inconsequential to relaxation,\index{relaxation} hence, the spherical or Euler angles\index{angles}\index{Euler angles} are undefined.  Therefore solely a single geometric parameter, either $\tau_m$ or $\Diff_{iso}$, can fully and sufficiently parameterise the diffusion tensor.\index{diffusion!tensor}  The correlation function for the global rotational\index{rotation} diffusion is


{\footnotesize \begin{verbatim}
             1   - tau / tm
    C(tau) = - e            ,
             5
\end{verbatim}}

To select isotropic\index{diffusion!sphere (isotropic)} diffusion, the parameters argument should be a single floating point\index{floating point number} number.  The number is the value of the isotropic\index{diffusion!sphere (isotropic)} global correlation time,\index{correlation time} $\tau_m$, in seconds. To specify the time in nanoseconds, set the \quotecmd{time\_scale} argument to 1e-9.  Alternative parameters can be used by changing the \quotecmd{param\_types} flag to the following integers


\begin{description}
\item[0 --]  $\tau_m$   (Default), 
\item[1 --]  $\Diff_{iso}$, 
\end{description}


where


\begin{itemize}
\item[] 1 / $\tau_m$ = 6$\Diff_{iso}$. 
\end{itemize}



\subsubsection{The spheroid\index{diffusion!spheroid (axially symmetric)|textbf} (axially symmetric diffusion)}

When two of the three eigenvalues\index{eigenvalues} of the diffusion tensor\index{diffusion!tensor} are equal, the molecule\index{molecule} diffuses as a spheroid.\index{diffusion!spheroid (axially symmetric)}  Four pieces of information are required to specify this tensor, the two geometric parameters, $\Diff_{iso}$ and $\Diff_a$, and the two orientational parameters, the polar angle\index{angles} $\theta$ and the azimuthal angle\index{angles} $\phi$ describing the orientation of the axis of symmetry.  The correlation function of the global diffusion is


{\footnotesize \begin{verbatim}
               _1_
             1 \          - tau / tau_i
    C(tau) = -  >  ci . e              ,
             5 /__
               i=-1
\end{verbatim}}

where


\begin{itemize}
\item[] c-1 = 1/4 (3 $\delta_z$\^{}2 - 1)\^{}2, 
\item[] c0  = 3 $\delta_z$\^{}2 (1 - $\delta_z$\^{}2), 
\item[] c1  = 3/4 ($\delta_z$\^{}2 - 1)\^{}2, 
\end{itemize}


and


\begin{itemize}
\item[] 1 / $\tau$ -1 = 6$\Diff_{iso}$ - 2$\Diff_a$, 
\item[] 1 / $\tau$ 0  = 6$\Diff_{iso}$ - $\Diff_a$, 
\item[] 1 / $\tau$ 1  = 6$\Diff_{iso}$ + 2$\Diff_a$. 
\end{itemize}


The direction cosine $\delta_z$ is defined as the cosine of the angle\index{angles} $\alpha$ between the XH bond vector and the unique axis of the diffusion tensor.\index{diffusion!tensor}


To select axially symmetric\index{diffusion!spheroid (axially symmetric)} anisotropic\index{diffusion!anisotropic} diffusion, the parameters argument should be a tuple of floating point\index{floating point number} numbers of length four.  A tuple is a type of data structure enclosed in round brackets, the elements of which are separated by commas.  Alternative sets of parameters, \quotecmd{param\_types}, are


\begin{description}
\item[0 --]  ($\tau_m$, $\Diff_a$, $\theta$, $\phi$)   (Default), 
\item[1 --]  ($\Diff_{iso}$, $\Diff_a$, $\theta$, $\phi$), 
\item[2 --]  ($\tau_m$, $\Diff_{ratio}$, $\theta$, $\phi$), 
\item[3 --]  ($\Diff_\Par$, $\Diff_\Per$, $\theta$, $\phi$), 
\item[4 --]  ($\Diff_{iso}$, $\Diff_{ratio}$, $\theta$, $\phi$), 
\end{description}


where


\begin{itemize}
\item[] $\tau_m$ = 1 / 6$\Diff_{iso}$, 
\item[] $\Diff_{iso}$ = 1/3 ($\Diff_\Par$ + 2$\Diff_\Per$), 
\item[] $\Diff_a$ = $\Diff_\Par$ - $\Diff_\Per$, 
\item[] $\Diff_{ratio}$ = $\Diff_\Par$ / $\Diff_\Per$. 
\end{itemize}


The spherical angles\index{angles} \{$\theta$, $\phi$\} orienting the unique axis of the diffusion tensor\index{diffusion!tensor} within the PDB\index{PDB} frame are defined between


\begin{itemize}
\item[] 0 $\le$ $\theta$ $\le$ $\pi$, 
\item[] 0 $\le$ $\phi$ $\le$ 2$\pi$, 
\end{itemize}


while the angle\index{angles} $\alpha$ which is the angle\index{angles} between this axis and the given XH bond vector is defined between


\begin{itemize}
\item[] 0 $\le$ $\alpha$ $\le$ 2$\pi$. 
\end{itemize}


The \quotecmd{spheroid\_type} argument should be \quotecmd{oblate}, \quotecmd{prolate}, or None.  The argument will be ignored if the diffusion tensor\index{diffusion!tensor} is not axially symmetric.\index{diffusion!spheroid (axially symmetric)}  If \quotecmd{oblate} is given, then the constraint\index{constraint} $\Diff_a$ $\le$ 0 is used while if \quotecmd{prolate} is given, then the constraint\index{constraint} $\Diff_a$ $\ge$ 0 is used.  If nothing is supplied, then $\Diff_a$ will be allowed to have any values.  To prevent minimisation\index{minimisation} of diffusion tensor\index{diffusion!tensor} parameters in a space with two minima, it is recommended to specify which tensor is to be minimised,\index{minimisation} thereby partitioning the two minima into the two subspaces along the boundry\index{parameter!bounds} $\Diff_a$ = 0.



\subsubsection{The ellipsoid\index{diffusion!ellipsoid (asymmetric)|textbf} (rhombic diffusion)}

When all three eigenvalues\index{eigenvalues} of the diffusion tensor\index{diffusion!tensor} are different, the molecule\index{molecule} diffuses as an ellipsoid.\index{diffusion!ellipsoid (asymmetric)}  This diffusion is also known as fully anisotropic,\index{diffusion!anisotropic} asymmetric,\index{diffusion!ellipsoid (asymmetric)} or rhombic. The full tensor is specified by six pieces of information, the three geometric parameters $\Diff_{iso}$, $\Diff_a$, and $\Diff_r$ representing the isotropic,\index{diffusion!sphere (isotropic)} anisotropic,\index{diffusion!anisotropic} and rhombic components of the tensor, and the three Euler angles\index{angles}\index{Euler angles} $\alpha$, $\beta$, and $\gamma$ orienting the tensor within the PDB\index{PDB} frame.  The correlation function is


{\footnotesize \begin{verbatim}
               _2_
             1 \          - tau / tau_i
    C(tau) = -  >  ci . e              ,
             5 /__
               i=-2
\end{verbatim}}

where the weights on the exponentials are


\begin{itemize}
\item[] c-2 = 1/4 (d + e), 
\item[] c-1 = 3 $\delta_y$\^{}2 $\delta_z$\^{}2, 
\item[] c0  = 3 $\delta_x$\^{}2 $\delta_z$\^{}2, 
\item[] c1  = 3 $\delta_x$\^{}2 $\delta_y$\^{}2, 
\item[] c2  = 1/4 (d + e). 
\end{itemize}


Let


\begin{itemize}
\item[] $\mathfrak{R}$ = sqrt(1 + 3$\Diff_r$), 
\end{itemize}


then


\begin{itemize}
\item[] d = 3 ($\delta_x$\^{}4 + $\delta_y$\^{}4 + $\delta_z$\^{}4) - 1, 
\item[] e = - 1 / $\mathfrak{R}$ ((1 + 3$\Diff_r$)($\delta_x$\^{}4 + 2$\delta_y$\^{}2 $\delta_z$\^{}2) + (1 - 3$\Diff_r$)($\delta_y$\^{}4 + 2$\delta_x$\^{}2 $\delta_z$\^{}2) - 2($\delta_z$\^{}4 + 2$\delta_x$\^{}2 $\delta_y$\^{}2)). 
\end{itemize}


The correlation times\index{correlation time} are


\begin{itemize}
\item[] 1 / $\tau$ -2 = 6$\Diff_{iso}$ - 2$\Diff_a$ . $\mathfrak{R}$, 
\item[] 1 / $\tau$ -1 = 6$\Diff_{iso}$ - $\Diff_a$ (1 + 3$\Diff_r$), 
\item[] 1 / $\tau$ 0  = 6$\Diff_{iso}$ - $\Diff_a$ (1 - 3$\Diff_r$), 
\item[] 1 / $\tau$ 1  = 6$\Diff_{iso}$ + 2$\Diff_a$, 
\item[] 1 / $\tau$ 1  = 6$\Diff_{iso}$ + 2$\Diff_a$ . $\mathfrak{R}$. 
\end{itemize}


The three direction cosines $\delta_x$, $\delta_y$, and $\delta_z$ are the coordinates of a unit vector parallel to the XH bond vector.  Hence the unit vector is [$\delta_x$, $\delta_y$, $\delta_z$].


To select fully anisotropic\index{diffusion!anisotropic} diffusion, the parameters argument should be a tuple of length six.  A tuple is a type of data structure enclosed in round brackets, the elements of which are separated by commas.  Alternative sets of parameters, \quotecmd{param\_types}, are


\begin{description}
\item[0 --]  ($\tau_m$, $\Diff_a$, $\Diff_r$, $\alpha$, $\beta$, $\gamma$)   (Default), 
\item[1 --]  ($\Diff_{iso}$, $\Diff_a$, $\Diff_r$, $\alpha$, $\beta$, $\gamma$), 
\item[2 --]  ($\Diff_x$, $\Diff_y$, $\Diff_z$, $\alpha$, $\beta$, $\gamma$), 
\end{description}


where


\begin{itemize}
\item[] $\tau_m$ = 1 / 6$\Diff_{iso}$, 
\item[] $\Diff_{iso}$ = 1/3 ($\Diff_x$ + $\Diff_y$ + $\Diff_z$), 
\item[] $\Diff_a$ = $\Diff_z$ - ($\Diff_x$ + $\Diff_y$)/2, 
\item[] $\Diff_r$ = ($\Diff_y$ - $\Diff_x$)/2$\Diff_a$. 
\end{itemize}


The angles\index{angles} $\alpha$, $\beta$, and $\gamma$ are the Euler angles\index{angles}\index{Euler angles} describing the diffusion tensor\index{diffusion!tensor} within the PDB\index{PDB} frame.  These angles\index{angles} are defined using the z-y-z axis rotation\index{rotation} notation where $\alpha$ is the initial rotation\index{rotation} angle\index{angles} around the z-axis, $\beta$ is the rotation\index{rotation} angle\index{angles} around the y-axis, and $\gamma$ is the final rotation\index{rotation} around the z-axis again.  The angles\index{angles} are defined between


\begin{itemize}
\item[] 0 $\le$ $\alpha$ $\le$ 2$\pi$, 
\item[] 0 $\le$ $\beta$ $\le$ $\pi$, 
\item[] 0 $\le$ $\gamma$ $\le$ 2$\pi$. 
\end{itemize}


Within the PDB\index{PDB} frame, the XH bond vector is described using the spherical angles\index{angles} $\theta$ and $\phi$ where $\theta$ is the polar angle\index{angles} and $\phi$ is the azimuthal angle\index{angles} defined between


\begin{itemize}
\item[] 0 $\le$ $\theta$ $\le$ $\pi$, 
\item[] 0 $\le$ $\phi$ $\le$ 2$\pi$. 
\end{itemize}



\subsubsection{Units}

The \quotecmd{time\_scale} argument should be a floating point\index{floating point number} number.  The only parameter affected by this value is $\tau_m$.


The \quotecmd{d\_scale} argument should also be a floating point\index{floating point number} number.  Parameters affected by this value are $\Diff_{iso}$, $\Diff_\Par$, $\Diff_\Per$, $\Diff_a$, $\Diff_x$, $\Diff_y$, and $\Diff_z$.  Significantly, $\Diff_r$ is not affected.


The \quotecmd{angle\_units} argument should either be the string \quotecmd{deg} or \quotecmd{rad}.  Parameters affected are $\theta$, $\phi$, $\alpha$, $\beta$, and $\gamma$.



\subsubsection{Examples}

To set an isotropic\index{diffusion!sphere (isotropic)} diffusion tensor\index{diffusion!tensor} with a correlation time\index{correlation time} of 10 ns, assigning it to the run \quotecmd{m1}, type:


\example{relax> diffusion\_tensor(`m1', 10e-9)}

\example{relax> diffusion\_tensor(run=`m1', params=10e-9)}

\example{relax> diffusion\_tensor(`m1', 10.0, 1e-9)}

\example{relax> diffusion\_tensor(run=`m1', params=10.0, time\_scale=1e-9, fixed=1)}

To select axially symmetric\index{diffusion!spheroid (axially symmetric)} diffusion with a $\tau_m$ value of 8.5 ns, $\Diff_{ratio}$ of 1.1, $\theta$ value of 20 degrees, and $\phi$ value of 20 degrees, and assign it to the run \quotecmd{m8}, type:


\example{relax> diffusion\_tensor(`m8', (8.5e-9, 1.1, 20.0, 20.0), param\_types=1)}

To select a spheroid\index{diffusion!spheroid (axially symmetric)} diffusion tensor\index{diffusion!tensor} with a $\Diff_\Par$ value of 1.698e7, $\Diff_\Per$ value of 1.417e7, $\theta$ value of 67.174 degrees, and $\phi$ value of -83.718 degrees, and assign it to the run \quotecmd{spheroid}, type one of:


\example{relax> diffusion\_tensor(`spheroid', (1.698e7, 1.417e7, 67.174, -83.718), param\_types=1)}

\example{relax> diffusion\_tensor(run=`spheroid', params=(1.698e7, 1.417e7, 67.174, -83.718), param\_types=1)}

\example{relax> diffusion\_tensor(`spheroid', (1.698e-1, 1.417e-1, 67.174, -83.718), param\_types=1, d\_scale=1e8)}

\example{relax> diffusion\_tensor(run=`spheroid', params=(1.698e-1, 1.417e-1, 67.174, -83.718), param\_types=1, d\_scale=1e8)}

\example{relax> diffusion\_tensor(`spheroid', (1.698e-1, 1.417e-1, 1.1724, -1.4612), param\_types=1, d\_scale=1e8, angle\_units=`rad')}

\example{relax> diffusion\_tensor(run=`spheroid', params=(1.698e-1, 1.417e-1, 1.1724, -1.4612), param\_types=1, d\_scale=1e8, angle\_units=`rad', fixed=1)}

To select ellipsoidal\index{diffusion!ellipsoid (asymmetric)} diffusion, type:


\example{relax> diffusion\_tensor(`m5', (1.340e7, 1.516e7, 1.691e7, -82.027, -80.573, 65.568), param\_types=2)}

To select and minimise\index{minimisation} a spherical diffusion tensor,\index{diffusion!tensor} type (followed by a minimisation\index{minimisation} command):


\example{relax> diffusion\_tensor(`diff', 10e-9, fixed=0)}



\newpage

\subsection{dx.execute}


\subsubsection{Synopsis}

Function for running OpenDX.\index{OpenDX, the program}



\subsubsection{Defaults}

\textsf{\textbf{dx.execute}(self, file=`map', dir=`dx', dx\_exe=`dx', vp\_exec=1)}


\subsubsection{Keyword Arguments}

\keyword{file:}  The file name prefix.  For example if file is set to \quotecmd{temp}, then the OpenDX\index{OpenDX, the program} program temp.net will be loaded. 

\keyword{dir:}  The directory to change to for running OpenDX.\index{OpenDX, the program}  If this is set to \quotecmd{None}, OpenDX\index{OpenDX, the program} will be run in the current directory. 

\keyword{dx\_exe:}  The OpenDX\index{OpenDX, the program} executable file. 

\keyword{vp\_exec:}  A flag specifying whether to execute the visual program automatically at start-up.  The default is 1 which turns execution on.  Setting the value to zero turns execution off. 





\newpage

\subsection{dx.map}


\subsubsection{Synopsis}

Function for creating a map\index{map} of the given space in OpenDX\index{OpenDX, the program} format.



\subsubsection{Defaults}

\textsf{\textbf{dx.map}(self, run=None, res\_num=None, map\_type=`Iso3D', inc=20, lower=None, upper=None, swap=None, file=`map', dir=`dx', point=None, point\_file=`point', remap=None, labels=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{res\_num:}  The residue number. 

\keyword{map\_type:}  The type of map\index{map} to create.  For example the default, a 3D isosurface, the type is \quotecmd{Iso3D}.  See below for more details. 

\keyword{inc:}  The number of increments to map\index{map} in each dimension.  This value controls the resolution of the map.\index{map} 

\keyword{lower:}  The lower bounds\index{parameter!bounds} of the space.  If you wish to change the lower bounds\index{parameter!bounds} of the map\index{map} then supply an array of length equal to the number of parameters in the model.  A lower bound\index{parameter!bounds} for each parameter must be supplied.  If nothing is supplied then the defaults will be used. 

\keyword{upper:}  The upper bounds\index{parameter!bounds} of the space.  If you wish to change the upper bounds\index{parameter!bounds} of the map\index{map} then supply an array of length equal to the number of parameters in the model.  A upper bound\index{parameter!bounds} for each parameter must be supplied.  If nothing is supplied then the defaults will be used. 

\keyword{swap:}  An array used to swap the position of the axes.  The length of the array should be the same as the number of parameters in the model.  The values should be integers specifying which elements to interchange.  For example if swap equals [0, 1, 2] for a three parameter model then the axes are not interchanged whereas if swap equals [1, 0, 2] then the first and second dimensions are interchanged. 

\keyword{file:}  The file name.  All the output files are prefixed with this name.  The main file containing the data points will be called the value of \quotecmd{file}.  The OpenDX\index{OpenDX, the program} program will be called \quotecmd{file.net} and the OpenDX\index{OpenDX, the program} import file will be called \quotecmd{file.general}. 

\keyword{dir:}  The directory to output files to.  Set this to \quotecmd{None} if you do not want the files to be placed in subdirectory.  If the directory does not exist, it will be created. 

\keyword{point:}  An array of parameter values where a point in the map,\index{map} shown as a red sphere,\index{diffusion!sphere (isotropic)} will be placed.  The length must be equal to the number of parameters. 

\keyword{point\_file:}  The name of that the point output files will be prefixed with. 

\keyword{remap:}  A user supplied remapping function.  This function will receive the parameter array and must return an array of equal length. 

\keyword{labels:}  The axis labels.  If supplied this argument should be an array of strings of length equal to the number of parameters. 




\subsubsection{Map\index{map|textbf} type}

The map\index{map} type can be changed by supplying the \quotecmd{map\_type} keyword argument.  Here is a list of currently supported map\index{map} types:


\begin{center}
\begin{tabular}{ll}
\toprule
Surface type & Pattern \\
\midrule
3D isosurface & \quotecmd{\^{}[Ii]so3[Dd]} \\
\bottomrule
\end{tabular}
\end{center}


Pattern syntax is simply regular expression\index{regular expression} syntax where square brackets \quotecmd{[]} means any character within the brackets, \quotecmd{\^{}} means the start of the string, etc.



\subsubsection{Examples}

The following commands will generate a map\index{map} of the extended model-free space defined as run \quotecmd{m5} which consists of the parameters \{$S^2_f$, $S^2_s$, $\tau_s$\}.  Files will be output into the directory \quotecmd{dx} and will be prefixed by \quotecmd{map}.  The residue, in this case, is number 6.


\example{relax> dx.map(`m5', 6)}

\example{relax> dx.map(`m5', 6, 20, `map', `dx')}

\example{relax> dx.map(`m5', res\_num=6, file=`map', dir=`dx')}

\example{relax> dx.map(run=`m5', res\_num=6, inc=20, file=`map', dir=`dx')}

\example{relax> dx.map(run=`m5', res\_num=6, type=`Iso3D', inc=20, swap=[0, 1, 2], file=`map', dir=`dx')}

The following commands will swap the $S^2_s$ and $\tau_s$ axes of this map.\index{map}


\example{relax> dx.map(`m5', res\_num=6, swap=[0, 2, 1])}

\example{relax> dx.map(run=`m5', res\_num=6, type=`Iso3D', inc=20, swap=[0, 2, 1], file=`map', dir=`dx')}

To map\index{map} the model-free space \quotecmd{m4} defined by the parameters \{$S^2$, $\tau_e$, $R_{ex}$\}, name the results \quotecmd{test}, and not place the files in a subdirectory, use the following commands (assuming residue 2).


\example{relax> dx.map(`m4', res\_num=2, file=`test', dir=None)}

\example{relax> dx.map(run=`m4', res\_num=2, inc=100, file=`test', dir=None)}



\newpage

\subsection{eliminate}


\subsubsection{Synopsis}

Function for model elimination.\index{model elimination}\index{model elimination}



\subsubsection{Defaults}

\textsf{\textbf{eliminate}(self, run=None, function=None, args=None)}


\subsubsection{Keyword arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 

\keyword{function:}  A user supplied function for model elimination.\index{model elimination}\index{model elimination} 

\keyword{args:}  A tuple of arguments for model elimination.\index{model elimination}\index{model elimination} 




\subsubsection{Description}

This function is used for model validation to eliminate or reject models prior to model selection.  Model validation is a part of mathematical modelling\index{modelling} whereby models are either accepted or rejected.


Empirical rules are used for model rejection and are listed below.  However these can be overridden by supplying a function.  The function should accept five arguments, a string defining a certain parameter, the value of the parameter, the run name, the minimisation\index{minimisation} instance (ie the residue index if the model is residue specific), and the function arguments.  If the model is rejected, the function should return 1, otherwise it should return 0.  The function will be executed multiple times, once for each parameter of the model.


The \quotecmd{args} keyword argument should be a tuple, a list enclosed in round brackets, and will be passed to the user supplied function or the inbuilt function.  For a description of the arguments accepted by the inbuilt functions, see below.


Once a model is rejected, the select flag corresponding to that model will be set to 0 so that model selection, or any other function, will then skip the model.



\subsubsection{Local $\tau_m$ model elimination\index{model elimination|textbf}\index{model elimination|textbf} rule}

The local $\tau_m$, in some cases, may exceed the value expected for a global correlation time.\index{correlation time} Generally the $\tau_m$ value will be stuck at the upper limit\index{parameter!limit} defined for the parameter.  These models are eliminated using the rule:


\begin{itemize}
\item[] $\tau_m$ $\ge$ c 
\end{itemize}


The default value of c is 50 ns, although this can be overridden by supplying the value (in seconds) as the first element of the args tuple.



\subsubsection{Internal correlation times\index{correlation time|textbf} \{$\tau_e$, $\tau_f$, $\tau_s$\} model elimination\index{model elimination|textbf}\index{model elimination|textbf} rules}

These parameters may experience the same problem as the local $\tau_m$ in that the model fails and the parameter value is stuck at the upper limit.\index{parameter!limit}  These parameters are constrained using the formula ($\tau_e$, $\tau_f$, $\tau_s$ $\le$ 2$\tau_m$).  These failed models are eliminated using the rule:


\begin{itemize}
\item[] $\tau_e$, $\tau_f$, $\tau_s$ $\ge$ c . $\tau_m$ 
\end{itemize}


The default value of c is 1.5.  Because of round-off errors and the constraint\index{constraint} algorithm, setting c to 2 will result in no models being eliminated as the minimised\index{minimisation} parameters will always be less than 2$\tau_m$.  The value can be changed by supplying the value as the second element of the tuple.



\subsubsection{Arguments}

The \quotecmd{args} argument must be a tuple of length 2, the elements of which must be numbers.  For example, to eliminate models which have a local $\tau_m$ value greater than 25 ns and models with internal correlation times\index{correlation time} greater than 1.5 times $\tau_m$, set \quotecmd{args} to (25 * 1e-9, 1.5).




\newpage

\subsection{fix}


\subsubsection{Synopsis}

Function for either fixing or allowing parameter values to change.



\subsubsection{Defaults}

\textsf{\textbf{fix}(self, run=None, element=None, fixed=1)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{element:}  Which element to fix. 

\keyword{fixed:}  A flag specifying if the parameters should be fixed or allowed to change. 




\subsubsection{Description}

The keyword argument \quotecmd{element} can be any of the following:


\quotecmd{diff} - the diffusion tensor\index{diffusion!tensor} parameters.  This will allow all diffusion tensor\index{diffusion!tensor} parameters to be toggled.


an integer - if an integer number is given, then all parameters for the residue corresponding to that number will be toggled.


\quotecmd{all\_res} - using this keyword, all parameters from all residues will be toggled.


\quotecmd{all} - all parameter will be toggled.  This is equivalent to combining both \quotecmd{diff} and \quotecmd{all\_res}.


The flag \quotecmd{fixed}, if set to 1, will fix parameters, while a value of 0 will allow parameters to vary.


Only parameters corresponding to the given run will be affected.




\newpage

\subsection{grace.view\index{Grace, the program|textbf}}


\subsubsection{Synopsis}

Function for running Grace.\index{Grace, the program}



\subsubsection{Defaults}

\textsf{\textbf{grace.view}(self, file=None, dir=`grace', grace\_exe=`xmgrace')}


\subsubsection{Keyword Arguments}

\keyword{file:}  The name of the file. 

\keyword{dir:}  The directory name. 

\keyword{grace\_exe:}  The Grace\index{Grace, the program} executable file. 




\subsubsection{Description}

This function can be used to execute Grace\index{Grace, the program} to view the specified file the Grace\index{Grace, the program} \quotecmd{.agr} file and the execute Grace.\index{Grace, the program} If the directory name is set to None, the file will be assumed to be in the current working directory.



\subsubsection{Examples}

To view the file \quotecmd{s2.agr} in the directory \quotecmd{grace}, type:


\example{relax> grace.view(file=`s2.agr')}

\example{relax> grace.view(file=`s2.agr', dir=`grace')}



\newpage

\subsection{grace.write\index{Grace, the program|textbf}}


\subsubsection{Synopsis}

Function for creating a grace\index{Grace, the program} \quotecmd{.agr} file.



\subsubsection{Defaults}

\textsf{\textbf{grace.write}(self, run=None, x\_data\_type=`res', y\_data\_type=None, res\_num=None, res\_name=None, plot\_data=`value', file=None, dir=`grace', force=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{x\_data\_type:}  The data type for the X-axis (no regular expression\index{regular expression} is allowed). 

\keyword{y\_data\_type:}  The data type for the Y-axis (no regular expression\index{regular expression} is allowed). 

\keyword{res\_num:}  The residue number (regular expression is allowed). 

\keyword{res\_name:}  The residue name (regular expression is allowed). 

\keyword{plot\_data:}  The data to use for the plot.\index{plot} 

\keyword{file:}  The name of the file. 

\keyword{dir:}  The directory name. 

\keyword{force:}  A flag which, if set to 1, will cause the file to be overwritten. 




\subsubsection{Description}

This function is designed to be as flexible as possible so that any combination of data can be plotted.\index{plot}  The output is in the format of a Grace\index{Grace, the program} plot\index{plot} (also known as ACE/gr, Xmgr, and xmgrace) which only supports two dimensional plots.\index{plot}  Three types of keyword arguments can be used to create various types of plot.\index{plot}  These include the X-axis and Y-axis data types, the residue number and name selection arguments, and an argument for selecting what to actually plot.\index{plot}


The X-axis and Y-axis data type arguments should be plain strings, regular expression\index{regular expression} is not allowed.  If the X-axis data type argument is not given, the plot\index{plot} will default to having the residue number along the x-axis.  The two axes of the Grace\index{Grace, the program} plot\index{plot} can be absolutely any of the data types listed in the tables below.  The only limitation,\index{parameter!limit} currently anyway, is that the data must belong to the same run.


The residue number and name arguments can be used to limit\index{parameter!limit} the residues used in the plot.\index{plot} The default is that all residues will be used, however, these arguments can be used to select a subset of all residues, or a single residue for plots\index{plot} of Monte Carlo simulations, etc.  Regular expression\index{regular expression} is allowed for both the residue number and name, and the number can either be an integer or a string.


The property which is actually plotted\index{plot} can be controlled by the \quotecmd{plot\_data} argument.  It can be one of the following:


\begin{description}
\item[\quotecmd{value} --]  Plot\index{plot} values (with errors if they exist). 
\item[\quotecmd{error} --]  Plot\index{plot} errors. 
\item[\quotecmd{sims} --]   Plot\index{plot} the simulation values. 
\end{description}



\subsubsection{Examples}

To write\index{write} the NOE values for all residues from the run \quotecmd{noe} to the Grace\index{Grace, the program} file \quotecmd{noe.agr}, type:


\example{relax> grace.write(`noe', `res', `noe', file=`noe.agr')}

\example{relax> grace.write(`noe', y\_data\_type=`noe', file=`noe.agr')}

\example{relax> grace.write(`noe', x\_data\_type=`res', y\_data\_type=`noe', file=`noe.agr')}

\example{relax> grace.write(run=`noe', y\_data\_type=`noe', file=`noe.agr', force=1)}

To create a Grace\index{Grace, the program} file of \quotecmd{S2} vs. \quotecmd{te} for all residues, type:


\example{relax> grace.write(`m2', `S2', `te', file=`s2\_te.agr')}

\example{relax> grace.write(`m2', x\_data\_type=`S2', y\_data\_type=`te', file=`s2\_te.agr')}

\example{relax> grace.write(run=`m2', x\_data\_type=`S2', y\_data\_type=`te', file=`s2\_te.agr', force=1)}

To create a Grace\index{Grace, the program} file of the Monte Carlo simulation values of \quotecmd{Rex} vs. \quotecmd{te} for residue 123, type:


\example{relax> grace.write(`m4', `Rex', `te', res\_num=123, plot\_data=`sims', file=`s2\_te.agr')}

\example{relax> grace.write(run=`m4', x\_data\_type=`Rex', y\_data\_type=`te', res\_num=123, plot\_data=`sims', file=`s2\_te.agr')}


\subsubsection{Regular expression\index{regular expression|textbf}}

The python\index{Python} function \quotecmd{match}, which uses regular expression,\index{regular expression} is used to determine which data type to set values to, therefore various data\_type strings can be used to select the same data type.  Patterns used for matching for specific data types are listed below.


This is a short description of python\index{Python} regular expression,\index{regular expression} for more information see the regular expression\index{regular expression} syntax section of the Python\index{Python} Library Reference.  Some of the regular expression\index{regular expression} syntax used in this function is:


\begin{description}
\item[\quotecmd{[]} --]  A sequence\index{sequence} or set of characters to match to a single character.  For example, \quotecmd{[Ss]2} will match both \quotecmd{S2} and \quotecmd{s2}. 
\item[\quotecmd{\^{}} --]  Match the start of the string. 
\item[\quotecmd{\$} --]  Match the end of the string.  For example, \quotecmd{\^{}[Ss]2\$} will match \quotecmd{s2} but not \quotecmd{S2f} or \quotecmd{s2s}. 
\item[\quotecmd{.} --]  Match any character. 
\item[\quotecmd{x*} --]  Match the character \quotecmd{x} any number of times, for example \quotecmd{x} will match, as will \quotecmd{xxxxx} 
\item[\quotecmd{.*} --]  Match any sequence\index{sequence} of characters of any length. 
\end{description}


Importantly, do not supply a string for the data type containing regular expression.\index{regular expression}  The regular expression\index{regular expression} is implemented so that various strings can be supplied which all match the same data type.



\subsubsection{Minimisation\index{minimisation|textbf} statistic data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Chi-squared statistic & \quotecmd{chi2} & \quotecmd{\^{}[Cc]hi2\$} or \quotecmd{\^{}[Cc]hi[-\_ ][Ss]quare} \\
 &  &  \\
Iteration count & \quotecmd{iter} & \quotecmd{\^{}[Ii]ter} \\
 &  &  \\
Function call count & \quotecmd{f\_count} & \quotecmd{\^{}[Ff].*[ -\_][Cc]ount} \\
 &  &  \\
Gradient call count & \quotecmd{g\_count} & \quotecmd{\^{}[Gg].*[ -\_][Cc]ount} \\
 &  &  \\
Hessian call count & \quotecmd{h\_count} & \quotecmd{\^{}[Hh].*[ -\_][Cc]ount} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Model-free data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Local $\tau_m$ & \quotecmd{tm} & \quotecmd{\^{}tm\$} \\
 &  &  \\
Order parameter $S^2$ & \quotecmd{s2} & \quotecmd{\^{}[Ss]2\$} \\
 &  &  \\
Order parameter $S^2_f$ & \quotecmd{s2f} & \quotecmd{\^{}[Ss]2f\$} \\
 &  &  \\
Order parameter $S^2_s$ & \quotecmd{s2s} & \quotecmd{\^{}[Ss]2s\$} \\
 &  &  \\
Correlation time $\tau_e$ & \quotecmd{te} & \quotecmd{\^{}te\$} \\
 &  &  \\
Correlation time $\tau_f$ & \quotecmd{tf} & \quotecmd{\^{}tf\$} \\
 &  &  \\
Correlation time $\tau_s$ & \quotecmd{ts} & \quotecmd{\^{}ts\$} \\
 &  &  \\
Chemical exchange & \quotecmd{rex} & \quotecmd{\^{}[Rr]ex\$} or \quotecmd{[Cc]emical[ -\_][Ee]xchange} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Reduced spectral density mapping\index{map|textbf} data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
$J(0)$ & \quotecmd{j0} & \quotecmd{\^{}[Jj]0\$} or \quotecmd{[Jj](0)} \\
 &  &  \\
$J(\omega_X)$ & \quotecmd{jwx} & \quotecmd{\^{}[Jj]w[Xx]\$} or \quotecmd{[Jj](w[Xx])} \\
 &  &  \\
$J(\omega_H)$ & \quotecmd{jwh} & \quotecmd{\^{}[Jj]w[Hh]\$} or \quotecmd{[Jj](w[Hh])} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{NOE calculation data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Reference intensity & \quotecmd{ref} & \quotecmd{\^{}[Rr]ef\$} or \quotecmd{[Rr]ef[ -\_][Ii]nt} \\
 &  &  \\
Saturated intensity & \quotecmd{sat} & \quotecmd{\^{}[Ss]at\$} or \quotecmd{[Ss]at[ -\_][Ii]nt} \\
 &  &  \\
NOE & \quotecmd{noe} & \quotecmd{\^{}[Nn][Oo][Ee]\$} \\
\bottomrule
\end{tabular}
\end{center}




\newpage

\subsection{grid\_search}


\subsubsection{Synopsis}

The grid search function.



\subsubsection{Defaults}

\textsf{\textbf{grid\_search}(self, run=None, lower=None, upper=None, inc=21, constraints=1, print\_flag=1)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run to apply the grid search to. 

\keyword{lower:}  An array of the lower bound\index{parameter!bounds} parameter values for the grid search.  The length of the array should be equal to the number of parameters in the model. 

\keyword{upper:}  An array of the upper bound\index{parameter!bounds} parameter values for the grid search.  The length of the array should be equal to the number of parameters in the model. 

\keyword{inc:}  The number of increments to search over.  If a single integer is given then the number of increments will be equal in all dimensions.  Different numbers of increments in each direction can be set if \quotecmd{inc} is set to an array of integers of length equal to the number of parameters. 

\keyword{constraints:}  A flag specifying whether the parameters should be constrained.  The default is to turn constraints\index{constraint} on (constraints=1). 

\keyword{print\_flag:}  The amount of information to print to screen.  Zero corresponds to minimal output while higher values increase the amount of output.  The default value is 1. 





\newpage

\subsection{init\_data}


\subsubsection{Synopsis}

Function for reinitialising self.relax.data



\subsubsection{Defaults}

\textsf{\textbf{init\_data}(self)}



\newpage

\subsection{intro\_off}


\subsubsection{Synopsis}

Function for turning the function introductions off.



\subsubsection{Defaults}

\textsf{\textbf{intro\_off}(self)}



\newpage

\subsection{intro\_on}


\subsubsection{Synopsis}

Function for turning the function introductions on.



\subsubsection{Defaults}

\textsf{\textbf{intro\_on}(self)}



\newpage

\subsection{jw\_mapping.set\_frq}


\subsubsection{Synopsis}

Function for selecting which relaxation\index{relaxation} data to use in the $J(\omega)$ mapping.\index{map}



\subsubsection{Defaults}

\textsf{\textbf{jw\_mapping.set\_frq}(self, run=None, frq=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{frq:}  The spectrometer frequency in Hz. 




\subsubsection{Description}

This function will select the relaxation\index{relaxation} data to use in the reduced spectral density mapping\index{map} corresponding to the given frequency.



\subsubsection{Examples}

\example{relax> jw\_mapping.set\_frq(`jw', 600.0 * 1e6)}

\example{relax> jw\_mapping.set\_frq(run=`jw', frq=600.0 * 1e6)}



\newpage

\subsection{minimise\index{minimisation|textbf}}


\subsubsection{Synopsis}

Minimisation\index{minimisation} function.



\subsubsection{Defaults}

\textsf{\textbf{minimise}(self, *args, **keywords)}


\subsubsection{Arguments}

The arguments, which should all be strings, specify the minimiser\index{minimisation} as well as its options.  A minimum of one argument is required.  As this calls the function \quotecmd{generic\_minimise} the full list of allowed arguments is shown below in the reproduced \quotecmd{generic\_minimise} docstring. Ignore all sections except those labelled as minimisation\index{minimisation} algorithms and minimisation\index{minimisation} options.  Also do not select the Method of Multipliers\index{minimisation techniques!Method of Multipliers} constraint\index{constraint} algorithm as this is used in combination with the given minimisation\index{minimisation} algorithm if the keyword argument \quotecmd{constraints} is set to 1.  The grid search algorithm should also not be selected as this is accessed using the \quotecmd{grid} function instead.  The first argument passed will be set to the minimisation\index{minimisation} algorithm while all other arguments will be set to the minimisation\index{minimisation} options.


Keyword arguments differ from normal arguments having the form \quotecmd{keyword = value}.  All arguments must precede keyword arguments in python.\index{Python}  For more information see the examples section below or the python\index{Python} tutorial.



\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{func\_tol:}  The function tolerance.  This is used to terminate minimisation\index{minimisation} once the function value between iterations is less than the tolerance.  The default value is 1e-25. 

\keyword{grad\_tol:}  The gradient tolerance.  Minimisation\index{minimisation} is terminated if the current gradient value is less than the tolerance.  The default value is None. 

\keyword{max\_iterations:}  The maximum number of iterations.  The default value is 1e7. 

\keyword{constraints:}  A flag specifying whether the parameters should be constrained.  The default is to turn constraints\index{constraint} on (constraints=1). 

\keyword{scaling:}  The diagonal scaling flag.  The default that scaling is on (scaling=1). 



\keyword{print\_flag:}  The amount of information to print to screen.  Zero corresponds to minimal output while higher values increase the amount of output.  The default value is 1. 




\subsubsection{Diagonal scaling}

Diagonal scaling is the transformation of parameter values such that each value has a similar order of magnitude.  Certain minimisation\index{minimisation} techniques, for example the trust region methods, perform extremely poorly with badly scaled problems.  In addition, methods which are insensitive to scaling such as Newton\index{minimisation techniques!Newton} minimisation\index{minimisation} may still benefit due to the minimisation\index{minimisation} of round off errors.


In Model-free analysis for example, if $S^2$ = 0.5, $\tau_e$ = 200 ps, and $R_{ex}$ = 15 1/s at 600 MHz, the unscaled parameter vector would be [0.5, 2.0e-10, 1.055e-18].  $R_{ex}$ is divided by (2 * $\pi$ * 600,000,000)**2 to make it field strength independent.  The scaling vector for this model may be something like [1.0, 1e-9, 1/(2 * $\pi$ * 6e8)**2].  By dividing the unscaled parameter vector by the scaling vector the scaled parameter vector is [0.5, 0.2, 15.0].  To revert to the original unscaled parameter vector, the scaled parameter vector and scaling vector are multiplied.



\subsubsection{Examples}

To minimise\index{minimisation} the model-free run \quotecmd{m4} using Newton\index{minimisation techniques!Newton} minimisation\index{minimisation} together with the GMW81 Hessian modification algorithm, the More and Thuente line search algorithm, a function tolerance of 1e-25, no gradient tolerance, a maximum of 10,000,000 iterations, constraints\index{constraint} turned on to limit\index{parameter!limit} parameter values, and have normal printout, type any combination of:


\example{relax> minimise(`newton', run=`m4')}

\example{relax> minimise(`Newton', run=`m4')}

\example{relax> minimise(`newton', `gmw', run=`m4')}

\example{relax> minimise(`newton', `mt', run=`m4')}

\example{relax> minimise(`newton', `gmw', `mt', run=`m4')}

\example{relax> minimise(`newton', `mt', `gmw', run=`m4')}

\example{relax> minimise(`newton', run=`m4', func\_tol=1e-25)}

\example{relax> minimise(`newton', run=`m4', func\_tol=1e-25, grad\_tol=None)}

\example{relax> minimise(`newton', run=`m4', max\_iter=1e7)}

\example{relax> minimise(`newton', run=name, constraints=1, max\_iter=1e7)}

\example{relax> minimise(`newton', run=`m4', print\_flag=1)}

To minimise\index{minimisation} the model-free run \quotecmd{m5} using constrained Simplex\index{minimisation techniques!simplex} minimisation\index{minimisation} with a maximum of 5000 iterations, type:


\example{relax> minimise(`simplex', run=`m5', constraints=1, max\_iter=5000)}


\subsubsection{Note}

{\footnotesize \begin{verbatim}

All the text which follows is a reproduction of the docstring of the generic_minimise
function.  Only take note of the minimisation algorithms and minimisation options sections,
the other sections are not relevant for this function.  The Grid search and Method of
Multipliers algorithms CANNOT be selected as minimisation algorithms for this function.

The section entitled Keyword Arguments is also completely inaccessible therefore please
ignore that text.

\end{verbatim}}

Generic minimisation\index{minimisation} function.


This is a generic function which can be used to access all minimisers\index{minimisation} using the same set of function arguments.  These are the function tolerance value for convergence tests, the maximum number of iterations, a flag specifying which data structures should be returned, and a flag specifying the amount of detail to print to screen.



\subsubsection{Keyword Arguments}

\keyword{func:}  The function which returns the value. 

\keyword{dfunc:}  The function which returns the gradient. 

\keyword{d2func:}  The function which returns the Hessian. 

\keyword{args:}  The tuple of arguments to supply to the functions func, dfunc, and d2func. 

\keyword{x0:}  The vector of initia$l$ parameter value estimates (as an array). 

\keyword{min\_algor:}  A string specifying which minimisation\index{minimisation} technique to use. 

\keyword{min\_options:}  A tuple to pass to the minimisation\index{minimisation} function as the min\_options keyword. 

\keyword{func\_tol:}  The function tolerance value.  Once the function value between iterations decreases below this value, minimisation\index{minimisation} is terminated. 

\keyword{grad\_tol:}  The gradient tolerance value. 

\keyword{maxiter:}  The maximum number of iterations. 

\keyword{A:}  Linear constraint\index{constraint} matrix m*n (A.x $\ge$ $b$). 

\keyword{b:}  Linear constraint\index{constraint} scalar vector (A.x $\ge$ $b$). 

\keyword{l:}  Lower bound\index{parameter!bounds} constraint\index{constraint} vector ($l$ $\le$ $x$ $\le$ $u$). 

\keyword{u:}  Upper bound\index{parameter!bounds} constraint\index{constraint} vector ($l$ $\le$ $x$ $\le$ $u$). 

\keyword{c:}  User supplied constraint\index{constraint} function. 

\keyword{dc:}  User supplied constraint\index{constraint} gradient function. 

\keyword{d2c:}  User supplied constraint\index{constraint} Hessian function. 

\keyword{ful$l$\_output:}  A flag specifying which data structures should be returned. 

\keyword{print\_flag:}  A flag specifying how much information should be printed to standard output during minimisation.\index{minimisation}  0 means no output, 1 means minima$l$ output, and values above 1 increase the amount of output printed. 




\subsubsection{Minimisation\index{minimisation|textbf} output}

The following values of the \quotecmd{full\_output} flag will return, in tuple form, the following data


\begin{description}
\item[0 --]  \quotecmd{xk}, 
\item[1 --]  \quotecmd{(xk, fk, $k$, f\_count, g\_count, h\_count, warning)}, 
\end{description}


where the data names correspond to


\begin{description}
\item[\quotecmd{xk} --]      The array of minimised\index{minimisation} parameter values, 
\item[\quotecmd{fk} --]      The minimised\index{minimisation} function value, 
\item[\quotecmd{k} --]       The number of iterations, 
\item[\quotecmd{f\_count} --] The number of function calls, 
\item[\quotecmd{g\_count} --] The number of gradient calls, 
\item[\quotecmd{h\_count} --] The number of Hessian calls, 
\item[\quotecmd{warning} --] The warning string. 
\end{description}



\subsubsection{Minimisation\index{minimisation|textbf} algorithms}

A minimisation\index{minimisation} function is selected if the minimisation\index{minimisation} algorithm argument, which should be a string, matches a certain pattern.  Because the python\index{Python} regular expression\index{regular expression} \quotecmd{match} statement is used, various strings can be supplied to select the same minimisation\index{minimisation} algorithm.  Below is a list of the minimisation\index{minimisation} algorithms available together with the corresponding patterns.


This is a short description of python\index{Python} regular expression,\index{regular expression} for more information, see the regular expression\index{regular expression} syntax section of the Python\index{Python} Library Reference.  Some of the regular expression\index{regular expression} syntax used in this function is:


\begin{description}
\item[\quotecmd{[]} --]  A sequence\index{sequence} or set of characters to match to a single character.  For example, \quotecmd{[Nn]ewton} will match both \quotecmd{Newton} and \quotecmd{newton}. 
\item[\quotecmd{\^{}} --]  Match the start of the string. 
\item[\quotecmd{\$} --]  Match the end of the string.  For example, \quotecmd{\^{}[Ll][Mm]\$} will match \quotecmd{lm} and \quotecmd{LM} but will not match if characters are placed either before or after these strings. 
\end{description}


To select a minimisation\index{minimisation} algorithm, set the argument to a string which matches the given pattern.


Parameter initialisation methods:


\begin{center}
\begin{tabular}{ll}
\toprule
Minimisation algorithm & Patterns \\
\midrule
Grid search & \quotecmd{\^{}[Gg]rid} \\
\bottomrule
\end{tabular}
\end{center}


Unconstrained line search methods:


\begin{center}
\begin{tabular}{ll}
\toprule
Minimisation algorithm & Patterns \\
\midrule
Back-and-forth coordinate descent & \quotecmd{\^{}[Cc][Dd]\$} or \quotecmd{\^{}[Cc]oordinate[ \_-][Dd]escent\$} \\
 &  \\
Steepest descent & \quotecmd{\^{}[Ss][Dd]\$} or \quotecmd{\^{}[Ss]teepest[ \_-][Dd]escent\$} \\
 &  \\
Quasi-Newton BFGS\index{minimisation techniques!BFGS} & \quotecmd{\^{}[Bb][Ff][Gg][Ss]\$} \\
 &  \\
Newton & \quotecmd{\^{}[Nn]ewton\$} \\
 &  \\
Newton-CG & \quotecmd{\^{}[Nn]ewton[ \_-][Cc][Gg]\$} or \quotecmd{\^{}[Nn][Cc][Gg]\$} \\
\bottomrule
\end{tabular}
\end{center}


Unconstrained trust-region methods:


\begin{center}
\begin{tabular}{ll}
\toprule
Minimisation algorithm & Patterns \\
\midrule
Cauchy point & \quotecmd{\^{}[Cc]auchy} \\
 &  \\
Dogleg & \quotecmd{\^{}[Dd]ogleg} \\
 &  \\
CG-Steihaug & \quotecmd{\^{}[Cc][Gg][-\_ ][Ss]teihaug} or \quotecmd{\^{}[Ss]teihaug} \\
 &  \\
Exact trust region & \quotecmd{\^{}[Ee]xact} \\
\bottomrule
\end{tabular}
\end{center}


Unconstrained conjugate gradient\index{minimisation techniques!conjugate gradient} methods:


\begin{center}
\begin{tabular}{ll}
\toprule
Minimisation algorithm & Patterns \\
\midrule
Fletcher-Reeves & \quotecmd{\^{}[Ff][Rr]\$} or \quotecmd{\^{}[Ff]letcher[-\_ ][Rr]eeves\$} \\
 &  \\
Polak-Ribi\`ere & \quotecmd{\^{}[Pp][Rr]\$} or \quotecmd{\^{}[Pp]olak[-\_ ][Rr]ibiere\$} \\
 &  \\
Polak-Ribi\`ere + & \quotecmd{\^{}[Pp][Rr]$\backslash$+\$} or \quotecmd{\^{}[Pp]olak[-\_ ][Rr]ibiere$\backslash$+\$} \\
 &  \\
Hestenes-Stiefel & \quotecmd{\^{}[Hh][Ss]\$} or \quotecmd{\^{}[Hh]estenes[-\_ ][Ss]tiefel\$} \\
\bottomrule
\end{tabular}
\end{center}


Miscellaneous unconstrained methods:


\begin{center}
\begin{tabular}{ll}
\toprule
Minimisation algorithm & Patterns \\
\midrule
Simplex & \quotecmd{\^{}[Ss]implex\$} \\
 &  \\
Levenberg-Marquardt & \quotecmd{\^{}[Ll][Mm]\$} or \quotecmd{\^{}[Ll]evenburg-[Mm]arquardt\$} \\
\bottomrule
\end{tabular}
\end{center}


Constrained methods:


\begin{center}
\begin{tabular}{ll}
\toprule
Minimisation algorithm & Patterns \\
\midrule
Method of Multipliers & \quotecmd{\^{}[Mm][Oo][Mm]\$} or \quotecmd{[Mm]ethod of [Mm]ultipliers\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Minimisation\index{minimisation|textbf} options}

The minimisation\index{minimisation} options can be given in any order.


Line search algorithms.  These are used in the line search methods and the conjugate gradient\index{minimisation techniques!conjugate gradient} methods.  The default is the Backtracking line search.


\begin{center}
\begin{tabular}{ll}
\toprule
Line search algorithm & Patterns \\
\midrule
Backtracking line search & \quotecmd{\^{}[Bb]ack} \\
 &  \\
Nocedal and Wright interpolation & \quotecmd{\^{}[Nn][Ww][Ii]} or \\
based line search & \quotecmd{\^{}[Nn]ocedal[ \_][Ww]right[ \_][Ii]nt} \\
 &  \\
Nocedal and Wright line search & \quotecmd{\^{}[Nn][Ww][Ww]} or \\
for the Wolfe conditions & \quotecmd{\^{}[Nn]ocedal[ \_][Ww]right[ \_][Ww]olfe} \\
 &  \\
More and Thuente line search & \quotecmd{\^{}[Mm][Tt]} or \quotecmd{\^{}[Mm]ore[ \_][Tt]huente\$} \\
 &  \\
No line search & \quotecmd{\^{}[Nn]one\$} \\
\bottomrule
\end{tabular}
\end{center}


Hessian modifications.  These are used in the Newton,\index{minimisation techniques!Newton} Dogleg,\index{minimisation techniques!dogleg} and Exact trust region\index{minimisation techniques!exact trust region} algorithms.


\begin{center}
\begin{tabular}{ll}
\toprule
Hessian modification & Patterns \\
\midrule
Unmodified Hessian & \quotecmd{[Nn]one} \\
 &  \\
Eigenvalue modification & \quotecmd{\^{}[Ee]igen} \\
 &  \\
Cholesky with added multiple of & \quotecmd{\^{}[Cc]hol} \\
the identity &  \\
 &  \\
The Gill, Murray, and Wright & \quotecmd{\^{}[Gg][Mm][Ww]\$} \\
modified Cholesky algorithm &  \\
 &  \\
The Schnabel and Eskow 1999 & \quotecmd{\^{}[Ss][Ee]99} \\
algorithm &  \\
\bottomrule
\end{tabular}
\end{center}


Hessian type, these are used in a few of the trust region methods including the Dogleg\index{minimisation techniques!dogleg} and Exact trust region\index{minimisation techniques!exact trust region} algorithms.  In these cases, when the Hessian type is set to Newton,\index{minimisation techniques!Newton} a Hessian modification can also be supplied as above.  The default Hessian type is Newton,\index{minimisation techniques!Newton} and the default Hessian modification when Newton\index{minimisation techniques!Newton} is selected is the GMW algorithm.


\begin{center}
\begin{tabular}{ll}
\toprule
Hessian type & Patterns \\
\midrule
Quasi-Newton BFGS\index{minimisation techniques!BFGS} & \quotecmd{\^{}[Bb][Ff][Gg][Ss]\$} \\
 &  \\
Newton & \quotecmd{\^{}[Nn]ewton\$} \\
\bottomrule
\end{tabular}
\end{center}


For Newton\index{minimisation techniques!Newton} minimisation,\index{minimisation} the default line search algorithm is the More and Thuente line search, while the default Hessian modification is the GMW algorithm.




\newpage

\subsection{model\_free.copy}


\subsubsection{Synopsis}

Function for copying\index{copy} model-free data from run1 to run2.



\subsubsection{Defaults}

\textsf{\textbf{model\_free.copy}(self, run1=None, run2=None, sim=None)}


\subsubsection{Keyword Arguments}

\keyword{run1:}  The name of the run to copy\index{copy} the sequence\index{sequence} from. 

\keyword{run2:}  The name of the run to copy\index{copy} the sequence\index{sequence} to. 

\keyword{sim:}  The simulation number. 




\subsubsection{Description}

This function will copy\index{copy} all model-free data from \quotecmd{run1} to \quotecmd{run2}.  Any model-free data in \quotecmd{run2} will be overwritten.  If the argument \quotecmd{sim} is an integer, then only data from that simulation will be copied.



\subsubsection{Examples}

To copy\index{copy} all model-free data from the run \quotecmd{m1} to the run \quotecmd{m2}, type:


\example{relax> model\_free.copy(`m1', `m2')}

\example{relax> model\_free.copy(run1=`m1', run2=`m2')}



\newpage

\subsection{model\_free.create\_model}


\subsubsection{Synopsis}

Function to create a model-free model.



\subsubsection{Defaults}

\textsf{\textbf{model\_free.create\_model}(self, run=None, model=None, equation=None, params=None, res\_num=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The run to assign the values to. 

\keyword{model:}  The name of the model-free model. 

\keyword{equation:}  The model-free equation. 

\keyword{params:}  The array of parameter names of the model. 

\keyword{res\_num:}  The residue number. 




\subsubsection{Model-free equation}

\quotecmd{mf\_orig} selects the original model-free equations with parameters \{$S^2$, $\tau_e$\}. \quotecmd{mf\_ext} selects the extended model-free equations with parameters \{$S^2_f$, $\tau_f$, $S^2$, $\tau_s$\}. \quotecmd{mf\_ext2} selects the extended model-free equations with parameters \{$S^2_f$, $\tau_f$, $S^2_s$, $\tau_s$\}.



\subsubsection{Model-free parameters}

The following parameters are accepted for the original model-free equation:


\begin{description}
\item[\quotecmd{S2} --]   The square of the generalised order parameter.\index{order parameter} 
\item[\quotecmd{te} --]   The effective correlation time.\index{correlation time} 
\end{description}


The following parameters are accepted for the extended model-free equation:


\begin{description}
\item[\quotecmd{S2f} --]  The square of the generalised order parameter\index{order parameter} of the faster motion. 
\item[\quotecmd{tf} --]   The effective correlation time\index{correlation time} of the faster motion. 
\item[\quotecmd{S2} --]   The square of the generalised order parameter\index{order parameter} $S^2$ = $S^2_f$ * $S^2_s$. 
\item[\quotecmd{ts} --]   The effective correlation time\index{correlation time} of the slower motion. 
\end{description}


The following parameters are accepted for the extended 2 model-free equation:


\begin{description}
\item[\quotecmd{S2f} --]  The square of the generalised order parameter\index{order parameter} of the faster motion. 
\item[\quotecmd{tf} --]   The effective correlation time\index{correlation time} of the faster motion. 
\item[\quotecmd{S2s} --]  The square of the generalised order parameter\index{order parameter} of the slower motion. 
\item[\quotecmd{ts} --]   The effective correlation time\index{correlation time} of the slower motion. 
\end{description}


The following parameters are accepted for all equations:


\begin{description}
\item[\quotecmd{Rex} --]  The chemical exchange\index{chemical exchange} relaxation.\index{relaxation} 
\item[\quotecmd{r} --]    The average bond length\index{bond length} $<$$r$$>$. 
\item[\quotecmd{CSA} --]  The chemical shift anisotropy. 
\end{description}



\subsubsection{Residue number}

If \quotecmd{res\_num} is supplied as an integer then the model will only be created for that residue, otherwise the model will be created for all residues.



\subsubsection{Examples}

The following commands will create the model-free model \quotecmd{m1} which is based on the original model-free equation and contains the single parameter \quotecmd{S2}.


\example{relax> model\_free.create\_model(`m1', `m1', `mf\_orig', [`S2'])}

\example{relax> model\_free.create\_model(run=`m1', model=`m1', params=[`S2'], equation=`mf\_orig')}

The following commands will create the model-free model \quotecmd{large\_model} which is based on the extended model-free equation and contains the seven parameters \quotecmd{S2f}, \quotecmd{tf}, \quotecmd{S2}, \quotecmd{ts}, \quotecmd{Rex}, \quotecmd{CSA}, \quotecmd{r}.


\example{relax> model\_free.create\_model(`test', `large\_model', `mf\_ext', [`S2f', `tf', `S2', `ts', `Rex', `CSA', `r'])}

\example{relax> model\_free.create\_model(run=`test', model=`large\_model', params=[`S2f', `tf', `S2', `ts', `Rex', `CSA', `r'], equation=`mf\_ext')}



\newpage

\subsection{model\_free.delete}


\subsubsection{Synopsis}

Function for deleting all model-free data corresponding to the run.



\subsubsection{Defaults}

\textsf{\textbf{model\_free.delete}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Examples}

To delete\index{delete} all model-free data corresponding to the run \quotecmd{m2}, type:


\example{relax> model\_free.delete(`m2')}



\newpage

\subsection{model\_free.remove\_tm}


\subsubsection{Synopsis}

Function for removing the local $\tau_m$ parameter from a model.



\subsubsection{Defaults}

\textsf{\textbf{model\_free.remove\_tm}(self, run=None, res\_num=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The run to assign the values to. 

\keyword{res\_num:}  The residue number. 




\subsubsection{Description}

This function will remove the local $\tau_m$ parameter from the model-free parameters of the given run.  Model-free parameters must already exist within the run yet, if there is no local $\tau_m$, nothing will happen.


If no residue number is given, then the function will apply to all residues.



\subsubsection{Examples}

The following commands will remove the parameter \quotecmd{tm} from the run \quotecmd{local\_tm}:


\example{relax> model\_free.remove\_tm(`local\_tm')}

\example{relax> model\_free.remove\_tm(run=`local\_tm')}



\newpage

\subsection{model\_free.select\_model}


\subsubsection{Synopsis}

Function for the selection of a preset model-free model.



\subsubsection{Defaults}

\textsf{\textbf{model\_free.select\_model}(self, run=None, model=None, res\_num=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The run to assign the values to. 

\keyword{model:}  The name of the preset model. 




\subsubsection{The preset models}

The standard preset model-free models are


\begin{description}
\item[\quotecmd{m0} --]  [], 
\item[\quotecmd{m1} --]  [$S^2$], 
\item[\quotecmd{m2} --]  [$S^2$, $\tau_e$], 
\item[\quotecmd{m3} --]  [$S^2$, $R_{ex}$], 
\item[\quotecmd{m4} --]  [$S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{m5} --]  [$S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m6} --]  [$S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m7} --]  [$S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m8} --]  [$S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m9} --]  [$R_{ex}$]. 
\end{description}


The preset model-free models with optimisation of the CSA value are


\begin{description}
\item[\quotecmd{m10} --]  [CSA], 
\item[\quotecmd{m11} --]  [CSA, $S^2$], 
\item[\quotecmd{m12} --]  [CSA, $S^2$, $\tau_e$], 
\item[\quotecmd{m13} --]  [CSA, $S^2$, $R_{ex}$], 
\item[\quotecmd{m14} --]  [CSA, $S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{m15} --]  [CSA, $S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m16} --]  [CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m17} --]  [CSA, $S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m18} --]  [CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m19} --]  [CSA, $R_{ex}$]. 
\end{description}


The preset model-free models with optimisation of the bond length\index{bond length} are


\begin{description}
\item[\quotecmd{m20} --]  [$r$], 
\item[\quotecmd{m21} --]  [$r$, $S^2$], 
\item[\quotecmd{m22} --]  [$r$, $S^2$, $\tau_e$], 
\item[\quotecmd{m23} --]  [$r$, $S^2$, $R_{ex}$], 
\item[\quotecmd{m24} --]  [$r$, $S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{m25} --]  [$r$, $S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m26} --]  [$r$, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m27} --]  [$r$, $S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m28} --]  [$r$, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m29} --]  [$r$, CSA, $R_{ex}$]. 
\end{description}


The preset model-free models with both optimisation of the bond length\index{bond length} and CSA are


\begin{description}
\item[\quotecmd{m30} --]  [$r$, CSA], 
\item[\quotecmd{m31} --]  [$r$, CSA, $S^2$], 
\item[\quotecmd{m32} --]  [$r$, CSA, $S^2$, $\tau_e$], 
\item[\quotecmd{m33} --]  [$r$, CSA, $S^2$, $R_{ex}$], 
\item[\quotecmd{m34} --]  [$r$, CSA, $S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{m35} --]  [$r$, CSA, $S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m36} --]  [$r$, CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{m37} --]  [$r$, CSA, $S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m38} --]  [$r$, CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{m39} --]  [$r$, CSA, $R_{ex}$]. 
\end{description}


Warning:  The models in the thirties range fail when using standard R$_1$, R$_1$, and NOE relaxation\index{relaxation} data.  This is due to the extreme flexibly of these models where a change in the parameter \quotecmd{r} is compensated by a corresponding change in the parameter \quotecmd{CSA} and vice versa.


Additional preset model-free models, which are simply extensions of the above models with the addition of a local $\tau_m$ parameter are:


\begin{description}
\item[\quotecmd{tm0} --]  [$\tau_m$], 
\item[\quotecmd{tm1} --]  [$\tau_m$, $S^2$], 
\item[\quotecmd{tm2} --]  [$\tau_m$, $S^2$, $\tau_e$], 
\item[\quotecmd{tm3} --]  [$\tau_m$, $S^2$, $R_{ex}$], 
\item[\quotecmd{tm4} --]  [$\tau_m$, $S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{tm5} --]  [$\tau_m$, $S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm6} --]  [$\tau_m$, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm7} --]  [$\tau_m$, $S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm8} --]  [$\tau_m$, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm9} --]  [$\tau_m$, $R_{ex}$]. 
\end{description}


The preset model-free models with optimisation of the CSA value are


\begin{description}
\item[\quotecmd{tm10} --]  [$\tau_m$, CSA], 
\item[\quotecmd{tm11} --]  [$\tau_m$, CSA, $S^2$], 
\item[\quotecmd{tm12} --]  [$\tau_m$, CSA, $S^2$, $\tau_e$], 
\item[\quotecmd{tm13} --]  [$\tau_m$, CSA, $S^2$, $R_{ex}$], 
\item[\quotecmd{tm14} --]  [$\tau_m$, CSA, $S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{tm15} --]  [$\tau_m$, CSA, $S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm16} --]  [$\tau_m$, CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm17} --]  [$\tau_m$, CSA, $S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm18} --]  [$\tau_m$, CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm19} --]  [$\tau_m$, CSA, $R_{ex}$]. 
\end{description}


The preset model-free models with optimisation of the bond length\index{bond length} are


\begin{description}
\item[\quotecmd{tm20} --]  [$\tau_m$, $r$], 
\item[\quotecmd{tm21} --]  [$\tau_m$, $r$, $S^2$], 
\item[\quotecmd{tm22} --]  [$\tau_m$, $r$, $S^2$, $\tau_e$], 
\item[\quotecmd{tm23} --]  [$\tau_m$, $r$, $S^2$, $R_{ex}$], 
\item[\quotecmd{tm24} --]  [$\tau_m$, $r$, $S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{tm25} --]  [$\tau_m$, $r$, $S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm26} --]  [$\tau_m$, $r$, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm27} --]  [$\tau_m$, $r$, $S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm28} --]  [$\tau_m$, $r$, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm29} --]  [$\tau_m$, $r$, CSA, $R_{ex}$]. 
\end{description}


The preset model-free models with both optimisation of the bond length\index{bond length} and CSA are


\begin{description}
\item[\quotecmd{tm30} --]  [$\tau_m$, $r$, CSA], 
\item[\quotecmd{tm31} --]  [$\tau_m$, $r$, CSA, $S^2$], 
\item[\quotecmd{tm32} --]  [$\tau_m$, $r$, CSA, $S^2$, $\tau_e$], 
\item[\quotecmd{tm33} --]  [$\tau_m$, $r$, CSA, $S^2$, $R_{ex}$], 
\item[\quotecmd{tm34} --]  [$\tau_m$, $r$, CSA, $S^2$, $\tau_e$, $R_{ex}$], 
\item[\quotecmd{tm35} --]  [$\tau_m$, $r$, CSA, $S^2_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm36} --]  [$\tau_m$, $r$, CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$], 
\item[\quotecmd{tm37} --]  [$\tau_m$, $r$, CSA, $S^2_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm38} --]  [$\tau_m$, $r$, CSA, $S^2_f$, $\tau_f$, $S^2$, $\tau_s$, $R_{ex}$], 
\item[\quotecmd{tm39} --]  [$\tau_m$, $r$, CSA, $R_{ex}$]. 
\end{description}



\subsubsection{Residue number}

If \quotecmd{res\_num} is supplied as an integer then the model will only be selected for that residue, otherwise the model will be selected for all residues.



\subsubsection{Examples}

To pick model \quotecmd{m1} for all selected residues and assign it to the run \quotecmd{mixed}, type:


\example{relax> model\_free.select\_model(`mixed', `m1')}

\example{relax> model\_free.select\_model(run=`mixed', model=`m1')}



\newpage

\subsection{model\_selection}


\subsubsection{Synopsis}

Function for model selection.



\subsubsection{Defaults}

\textsf{\textbf{model\_selection}(self, method=None, modsel\_run=None, runs=None)}


\subsubsection{Keyword arguments}

\keyword{method:}  The model selection technique (see below). 

\keyword{modsel\_run:}  The run name to assign to the results of model selection. 

\keyword{runs:}  An array containing the names of all runs to include in model selection. 




\subsubsection{Description}

The following model selection methods are supported:


AIC:  Akaike's Information Criteria.


AICc:  Small sample size corrected AIC.


BIC:  Bayesian or Schwarz Information Criteria.


Bootstrap:  Bootstrap model selection.


CV:  Single-item-out cross-validation.


Expect:  The expected overall discrepancy (the true values of the parameters are required).


Farrow:  Old model-free method by Farrow et al., 1994.


Palmer:  Old model-free method by Mandel et al., 1995.


Overall:  The realised overall discrepancy (the true values of the parameters are required).


For the methods \quotecmd{Bootstrap}, \quotecmd{Expect}, and \quotecmd{Overall}, the function \quotecmd{monte\_carlo} should have previously been run with the type argument set to the appropriate value to modify its behaviour.


If the runs argument is not supplied then all runs currently set or loaded will be used for model selection, although this could cause problems.



\subsubsection{Example}

For model-free analysis, if the preset models 1 to 5 are minimised\index{minimisation} and loaded into the program, the following commands will carry out AIC model selection and assign the results to the run name \quotecmd{mixed}:


\example{relax> model\_selection(`AIC', `mixed')}

\example{relax> model\_selection(method=`AIC', modsel\_run=`mixed')}

\example{relax> model\_selection(`AIC', `mixed', [`m1', `m2', `m3', `m4', `m5'])}

\example{relax> model\_selection(method=`AIC', modsel\_run=`mixed', runs=[`m1', `m2', `m3', `m4', `m5'])}



\newpage

\subsection{molmol.clear\_history\index{Molmol, the program|textbf}}


\subsubsection{Synopsis}

Function for clearing the Molmol\index{Molmol, the program} command history.



\subsubsection{Defaults}

\textsf{\textbf{molmol.clear\_history}(self)}



\newpage

\subsection{molmol.command\index{Molmol, the program|textbf}}


\subsubsection{Synopsis}

Function for executing a user supplied Molmol\index{Molmol, the program} command.



\subsubsection{Defaults}

\textsf{\textbf{molmol.command}(self, command)}


\subsubsection{Example}

\example{relax> molmol.command("InitAll yes")}



\newpage

\subsection{molmol.view\index{Molmol, the program|textbf}}


\subsubsection{Synopsis}

Function for viewing the collection of molecules\index{molecule} extracted from the PDB\index{PDB} file.



\subsubsection{Defaults}

\textsf{\textbf{molmol.view}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run which the PDB\index{PDB} belongs to. 




\subsubsection{Example}

\example{relax> molmol.view(`m1')}

\example{relax> molmol.view(run=`pdb')}



\newpage

\subsection{monte\_carlo.create\_data}


\subsubsection{Synopsis}

Function for creating simulation data.



\subsubsection{Defaults}

\textsf{\textbf{monte\_carlo.create\_data}(self, run=None, method=`back\_calc')}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{method:}  The simulation method. 




\subsubsection{Description}

The method argument can either be set to \quotecmd{back\_calc} or \quotecmd{direct}, the choice of which determines the simulation type.  If the values or parameters of a run are calculated rather than minimised,\index{minimisation} this option will have no effect, hence, \quotecmd{back\_calc} and \quotecmd{direct} are identical.


For error analysis, the method argument should be set to \quotecmd{back\_calc} which will result in proper Monte Carlo simulations.  The data used for each simulation is back calculated from the minimised\index{minimisation} model parameters and is randomised using Gaussian noise where the standard deviation is from the original error set.  When the method is set to \quotecmd{back\_calc}, this function should only be called after the model or run is fully minimised.\index{minimisation}


The simulation type can be changed by setting the method argument to \quotecmd{direct}.  This will result in simulations which cannot be used in error analysis and which are no longer Monte Carlo simulations.  However, these simulations are required for certain model selection techniques (see the documentation for the model selection function for details), and can be used for other purposes.  Rather than the data being back calculated from the fitted model parameters, the data is generated by taking the original data and randomising using Gaussian noise with the standard deviations set to the original error set.



\subsubsection{Monte Carlo Simulation Overview}

For proper error analysis using Monte Carlo simulations, a sequence\index{sequence} of function calls is required for running the various simulation components.  The steps necessary for implementing Monte Carlo simulations are:


1.  The measured data set together with the corresponding error set should be loaded into relax.


2.  Either minimisation\index{minimisation} is used to optimise\index{optimise} the parameters of the chosen model, or a calculation is run.


3.  To initialise and turn on Monte Carlo simulations, the number of simulations, $n$, needs to be set.


4.  The simulation data needs to be created either by back calculation from the fully minimised\index{minimisation} model parameters from step 2 or by direct calculation when values are calculated rather than minimised.\index{minimisation}  The error set is used to randomise each simulation data set by assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo simulation.


5.  Prior to minimisation\index{minimisation} of the parameters of each simulation, initial parameter estimates are required.  These are taken as the optimised\index{optimise} model parameters.  An alternative is to use a grid search for each simulation to generate initial estimates, however this is extremely computationally expensive.  For the case where values are calculated rather than minimised,\index{minimisation} this step should be skipped (although the results will be unaffected if this is accidentally run).


6.  Each simulation requires minimisation\index{minimisation} or calculation.  The same techniques as used in step 2, excluding the grid search when minimising, should be used for the simulations.


7.  Failed simulations are removed using the techniques of model elimination.\index{model elimination}\index{model elimination}


8.  The model parameter errors are calculated from the distribution of simulation parameters.


Monte Carlo simulations can be turned on or off using functions within this class.  Once the function for setting up simulations has been called, simulations will be turned on.  The effect of having simulations turned on is that the functions used for minimisation\index{minimisation} (grid search, minimise,\index{minimisation} etc) or calculation will only affect the simulation parameters and not the model parameters.  By subsequently turning simulations off using the appropriate function, the functions used in minimisation\index{minimisation} will affect the model parameters and not the simulation parameters.


An example, for model-free analysis, which includes only the functions required for implementing the above steps is:


\example{relax> grid\_search(`m1', inc=11)                                 \# Step 2.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 2.}

\example{relax> monte\_carlo.setup(`m1', number=500)                       \# Step 3.}

\example{relax> monte\_carlo.create\_data(`m1', method=`back\_calc')         \# Step 4.}

\example{relax> monte\_carlo.initial\_values(`m1')                          \# Step 5.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 6.}

\example{relax> eliminate(`m1')                                           \# Step 7.}

\example{relax> monte\_carlo.error\_analysis(`m1')                          \# Step 8.}

An example for reduced spectral density mapping\index{map} is:


\example{relax> calc(`600MHz')                                            \# Step 2.}

\example{relax> monte\_carlo.setup(`600MHz', number=500)                   \# Step 3.}

\example{relax> monte\_carlo.create\_data(`600MHz', method=`back\_calc')     \# Step 4.}

\example{relax> calc(`600MHz')                                            \# Step 6.}

\example{relax> monte\_carlo.error\_analysis(`600MHz')                      \# Step 8.}



\newpage

\subsection{monte\_carlo.error\_analysis}


\subsubsection{Synopsis}

Function for calculating parameter errors from the Monte Carlo simulations.



\subsubsection{Defaults}

\textsf{\textbf{monte\_carlo.error\_analysis}(self, run=None, prune=0.0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{prune:}  Legacy argument corresponding to \quotecmd{trim} in Art Palmer's Modelfree program. 




\subsubsection{Description}

Parameter errors are calculated as the standard deviation of the distribution of parameter values.  This function should never be used if parameter values are obtained by minimisation\index{minimisation} and the simulation data are generated using the method \quotecmd{direct}.  The reason is because only true Monte Carlo simulations can give the true parameter errors.


The prune argument is legacy code which corresponds to the \quotecmd{trim} option in Art Palmer's Modelfree program.  To remove failed simulations, the eliminate function should be used prior to this function.  Eliminating the simulations specifically identifies and removes the failed simulations whereas the prune argument will only, in a few cases, positively identify failed simulations but only if severe parameter limits\index{parameter!limit} have been imposed.  Most failed models will pass through the pruning process and hence cause a catastrophic increase in the parameter errors.  If the argument must be used, the following must be taken into account. If the values or parameters of a run are calculated rather than minimised,\index{minimisation} the prune argument must be set to zero.  The value of this argument is proportional to the number of simulations removed prior to error calculation.  If prune is set to 0.0, all simulations are used for calculating errors, whereas a value of 1.0 excludes all data.  In almost all cases prune must be set to zero, any value greater than zero will result in an underestimation of the error values.  If a value is supplied, the lower and upper tails of the distribution of chi-squared\index{chi-squared} values will be excluded from the error calculation.



\subsubsection{Monte Carlo Simulation Overview}

For proper error analysis using Monte Carlo simulations, a sequence\index{sequence} of function calls is required for running the various simulation components.  The steps necessary for implementing Monte Carlo simulations are:


1.  The measured data set together with the corresponding error set should be loaded into relax.


2.  Either minimisation\index{minimisation} is used to optimise\index{optimise} the parameters of the chosen model, or a calculation is run.


3.  To initialise and turn on Monte Carlo simulations, the number of simulations, $n$, needs to be set.


4.  The simulation data needs to be created either by back calculation from the fully minimised\index{minimisation} model parameters from step 2 or by direct calculation when values are calculated rather than minimised.\index{minimisation}  The error set is used to randomise each simulation data set by assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo simulation.


5.  Prior to minimisation\index{minimisation} of the parameters of each simulation, initial parameter estimates are required.  These are taken as the optimised\index{optimise} model parameters.  An alternative is to use a grid search for each simulation to generate initial estimates, however this is extremely computationally expensive.  For the case where values are calculated rather than minimised,\index{minimisation} this step should be skipped (although the results will be unaffected if this is accidentally run).


6.  Each simulation requires minimisation\index{minimisation} or calculation.  The same techniques as used in step 2, excluding the grid search when minimising, should be used for the simulations.


7.  Failed simulations are removed using the techniques of model elimination.\index{model elimination}\index{model elimination}


8.  The model parameter errors are calculated from the distribution of simulation parameters.


Monte Carlo simulations can be turned on or off using functions within this class.  Once the function for setting up simulations has been called, simulations will be turned on.  The effect of having simulations turned on is that the functions used for minimisation\index{minimisation} (grid search, minimise,\index{minimisation} etc) or calculation will only affect the simulation parameters and not the model parameters.  By subsequently turning simulations off using the appropriate function, the functions used in minimisation\index{minimisation} will affect the model parameters and not the simulation parameters.


An example, for model-free analysis, which includes only the functions required for implementing the above steps is:


\example{relax> grid\_search(`m1', inc=11)                                 \# Step 2.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 2.}

\example{relax> monte\_carlo.setup(`m1', number=500)                       \# Step 3.}

\example{relax> monte\_carlo.create\_data(`m1', method=`back\_calc')         \# Step 4.}

\example{relax> monte\_carlo.initial\_values(`m1')                          \# Step 5.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 6.}

\example{relax> eliminate(`m1')                                           \# Step 7.}

\example{relax> monte\_carlo.error\_analysis(`m1')                          \# Step 8.}

An example for reduced spectral density mapping\index{map} is:


\example{relax> calc(`600MHz')                                            \# Step 2.}

\example{relax> monte\_carlo.setup(`600MHz', number=500)                   \# Step 3.}

\example{relax> monte\_carlo.create\_data(`600MHz', method=`back\_calc')     \# Step 4.}

\example{relax> calc(`600MHz')                                            \# Step 6.}

\example{relax> monte\_carlo.error\_analysis(`600MHz')                      \# Step 8.}



\newpage

\subsection{monte\_carlo.initial\_values}


\subsubsection{Synopsis}

Function for setting the initial simulation parameter values.



\subsubsection{Defaults}

\textsf{\textbf{monte\_carlo.initial\_values}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Description}

This function only effects runs where minimisation\index{minimisation} occurs and can therefore be skipped if the values or parameters of a run are calculated rather than minimised.\index{minimisation}  However, if accidentally run in this case, the results will be unaffected.  It should only be called after the model or run is fully minimised.\index{minimisation}  Once called, the functions \quotecmd{grid\_search} and \quotecmd{minimise} will only effect the simulations and not the model parameters.


The initial values of the parameters for each simulation is set to the minimised\index{minimisation} parameters of the model.  A grid search can be undertaken for each simulation instead, although this is computationally expensive and unnecessary.  The minimisation\index{minimisation} function should be executed for a second time after running this function.



\subsubsection{Monte Carlo Simulation Overview}

For proper error analysis using Monte Carlo simulations, a sequence\index{sequence} of function calls is required for running the various simulation components.  The steps necessary for implementing Monte Carlo simulations are:


1.  The measured data set together with the corresponding error set should be loaded into relax.


2.  Either minimisation\index{minimisation} is used to optimise\index{optimise} the parameters of the chosen model, or a calculation is run.


3.  To initialise and turn on Monte Carlo simulations, the number of simulations, $n$, needs to be set.


4.  The simulation data needs to be created either by back calculation from the fully minimised\index{minimisation} model parameters from step 2 or by direct calculation when values are calculated rather than minimised.\index{minimisation}  The error set is used to randomise each simulation data set by assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo simulation.


5.  Prior to minimisation\index{minimisation} of the parameters of each simulation, initial parameter estimates are required.  These are taken as the optimised\index{optimise} model parameters.  An alternative is to use a grid search for each simulation to generate initial estimates, however this is extremely computationally expensive.  For the case where values are calculated rather than minimised,\index{minimisation} this step should be skipped (although the results will be unaffected if this is accidentally run).


6.  Each simulation requires minimisation\index{minimisation} or calculation.  The same techniques as used in step 2, excluding the grid search when minimising, should be used for the simulations.


7.  Failed simulations are removed using the techniques of model elimination.\index{model elimination}\index{model elimination}


8.  The model parameter errors are calculated from the distribution of simulation parameters.


Monte Carlo simulations can be turned on or off using functions within this class.  Once the function for setting up simulations has been called, simulations will be turned on.  The effect of having simulations turned on is that the functions used for minimisation\index{minimisation} (grid search, minimise,\index{minimisation} etc) or calculation will only affect the simulation parameters and not the model parameters.  By subsequently turning simulations off using the appropriate function, the functions used in minimisation\index{minimisation} will affect the model parameters and not the simulation parameters.


An example, for model-free analysis, which includes only the functions required for implementing the above steps is:


\example{relax> grid\_search(`m1', inc=11)                                 \# Step 2.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 2.}

\example{relax> monte\_carlo.setup(`m1', number=500)                       \# Step 3.}

\example{relax> monte\_carlo.create\_data(`m1', method=`back\_calc')         \# Step 4.}

\example{relax> monte\_carlo.initial\_values(`m1')                          \# Step 5.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 6.}

\example{relax> eliminate(`m1')                                           \# Step 7.}

\example{relax> monte\_carlo.error\_analysis(`m1')                          \# Step 8.}

An example for reduced spectral density mapping\index{map} is:


\example{relax> calc(`600MHz')                                            \# Step 2.}

\example{relax> monte\_carlo.setup(`600MHz', number=500)                   \# Step 3.}

\example{relax> monte\_carlo.create\_data(`600MHz', method=`back\_calc')     \# Step 4.}

\example{relax> calc(`600MHz')                                            \# Step 6.}

\example{relax> monte\_carlo.error\_analysis(`600MHz')                      \# Step 8.}



\newpage

\subsection{monte\_carlo.off}


\subsubsection{Synopsis}

Function for turning simulations off.



\subsubsection{Defaults}

\textsf{\textbf{monte\_carlo.off}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Monte Carlo Simulation Overview}

For proper error analysis using Monte Carlo simulations, a sequence\index{sequence} of function calls is required for running the various simulation components.  The steps necessary for implementing Monte Carlo simulations are:


1.  The measured data set together with the corresponding error set should be loaded into relax.


2.  Either minimisation\index{minimisation} is used to optimise\index{optimise} the parameters of the chosen model, or a calculation is run.


3.  To initialise and turn on Monte Carlo simulations, the number of simulations, $n$, needs to be set.


4.  The simulation data needs to be created either by back calculation from the fully minimised\index{minimisation} model parameters from step 2 or by direct calculation when values are calculated rather than minimised.\index{minimisation}  The error set is used to randomise each simulation data set by assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo simulation.


5.  Prior to minimisation\index{minimisation} of the parameters of each simulation, initial parameter estimates are required.  These are taken as the optimised\index{optimise} model parameters.  An alternative is to use a grid search for each simulation to generate initial estimates, however this is extremely computationally expensive.  For the case where values are calculated rather than minimised,\index{minimisation} this step should be skipped (although the results will be unaffected if this is accidentally run).


6.  Each simulation requires minimisation\index{minimisation} or calculation.  The same techniques as used in step 2, excluding the grid search when minimising, should be used for the simulations.


7.  Failed simulations are removed using the techniques of model elimination.\index{model elimination}\index{model elimination}


8.  The model parameter errors are calculated from the distribution of simulation parameters.


Monte Carlo simulations can be turned on or off using functions within this class.  Once the function for setting up simulations has been called, simulations will be turned on.  The effect of having simulations turned on is that the functions used for minimisation\index{minimisation} (grid search, minimise,\index{minimisation} etc) or calculation will only affect the simulation parameters and not the model parameters.  By subsequently turning simulations off using the appropriate function, the functions used in minimisation\index{minimisation} will affect the model parameters and not the simulation parameters.


An example, for model-free analysis, which includes only the functions required for implementing the above steps is:


\example{relax> grid\_search(`m1', inc=11)                                 \# Step 2.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 2.}

\example{relax> monte\_carlo.setup(`m1', number=500)                       \# Step 3.}

\example{relax> monte\_carlo.create\_data(`m1', method=`back\_calc')         \# Step 4.}

\example{relax> monte\_carlo.initial\_values(`m1')                          \# Step 5.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 6.}

\example{relax> eliminate(`m1')                                           \# Step 7.}

\example{relax> monte\_carlo.error\_analysis(`m1')                          \# Step 8.}

An example for reduced spectral density mapping\index{map} is:


\example{relax> calc(`600MHz')                                            \# Step 2.}

\example{relax> monte\_carlo.setup(`600MHz', number=500)                   \# Step 3.}

\example{relax> monte\_carlo.create\_data(`600MHz', method=`back\_calc')     \# Step 4.}

\example{relax> calc(`600MHz')                                            \# Step 6.}

\example{relax> monte\_carlo.error\_analysis(`600MHz')                      \# Step 8.}



\newpage

\subsection{monte\_carlo.on}


\subsubsection{Synopsis}

Function for turning simulations on.



\subsubsection{Defaults}

\textsf{\textbf{monte\_carlo.on}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Monte Carlo Simulation Overview}

For proper error analysis using Monte Carlo simulations, a sequence\index{sequence} of function calls is required for running the various simulation components.  The steps necessary for implementing Monte Carlo simulations are:


1.  The measured data set together with the corresponding error set should be loaded into relax.


2.  Either minimisation\index{minimisation} is used to optimise\index{optimise} the parameters of the chosen model, or a calculation is run.


3.  To initialise and turn on Monte Carlo simulations, the number of simulations, $n$, needs to be set.


4.  The simulation data needs to be created either by back calculation from the fully minimised\index{minimisation} model parameters from step 2 or by direct calculation when values are calculated rather than minimised.\index{minimisation}  The error set is used to randomise each simulation data set by assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo simulation.


5.  Prior to minimisation\index{minimisation} of the parameters of each simulation, initial parameter estimates are required.  These are taken as the optimised\index{optimise} model parameters.  An alternative is to use a grid search for each simulation to generate initial estimates, however this is extremely computationally expensive.  For the case where values are calculated rather than minimised,\index{minimisation} this step should be skipped (although the results will be unaffected if this is accidentally run).


6.  Each simulation requires minimisation\index{minimisation} or calculation.  The same techniques as used in step 2, excluding the grid search when minimising, should be used for the simulations.


7.  Failed simulations are removed using the techniques of model elimination.\index{model elimination}\index{model elimination}


8.  The model parameter errors are calculated from the distribution of simulation parameters.


Monte Carlo simulations can be turned on or off using functions within this class.  Once the function for setting up simulations has been called, simulations will be turned on.  The effect of having simulations turned on is that the functions used for minimisation\index{minimisation} (grid search, minimise,\index{minimisation} etc) or calculation will only affect the simulation parameters and not the model parameters.  By subsequently turning simulations off using the appropriate function, the functions used in minimisation\index{minimisation} will affect the model parameters and not the simulation parameters.


An example, for model-free analysis, which includes only the functions required for implementing the above steps is:


\example{relax> grid\_search(`m1', inc=11)                                 \# Step 2.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 2.}

\example{relax> monte\_carlo.setup(`m1', number=500)                       \# Step 3.}

\example{relax> monte\_carlo.create\_data(`m1', method=`back\_calc')         \# Step 4.}

\example{relax> monte\_carlo.initial\_values(`m1')                          \# Step 5.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 6.}

\example{relax> eliminate(`m1')                                           \# Step 7.}

\example{relax> monte\_carlo.error\_analysis(`m1')                          \# Step 8.}

An example for reduced spectral density mapping\index{map} is:


\example{relax> calc(`600MHz')                                            \# Step 2.}

\example{relax> monte\_carlo.setup(`600MHz', number=500)                   \# Step 3.}

\example{relax> monte\_carlo.create\_data(`600MHz', method=`back\_calc')     \# Step 4.}

\example{relax> calc(`600MHz')                                            \# Step 6.}

\example{relax> monte\_carlo.error\_analysis(`600MHz')                      \# Step 8.}



\newpage

\subsection{monte\_carlo.setup}


\subsubsection{Synopsis}

Function for setting up Monte Carlo simulations.



\subsubsection{Defaults}

\textsf{\textbf{monte\_carlo.setup}(self, run=None, number=500)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{number:}  The number of Monte Carlo simulations. 




\subsubsection{Description}

This function must be called prior to any of the other Monte Carlo functions.  The effect is that the number of simulations for the given run will be set and that simulations will be turned on.



\subsubsection{Monte Carlo Simulation Overview}

For proper error analysis using Monte Carlo simulations, a sequence\index{sequence} of function calls is required for running the various simulation components.  The steps necessary for implementing Monte Carlo simulations are:


1.  The measured data set together with the corresponding error set should be loaded into relax.


2.  Either minimisation\index{minimisation} is used to optimise\index{optimise} the parameters of the chosen model, or a calculation is run.


3.  To initialise and turn on Monte Carlo simulations, the number of simulations, $n$, needs to be set.


4.  The simulation data needs to be created either by back calculation from the fully minimised\index{minimisation} model parameters from step 2 or by direct calculation when values are calculated rather than minimised.\index{minimisation}  The error set is used to randomise each simulation data set by assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo simulation.


5.  Prior to minimisation\index{minimisation} of the parameters of each simulation, initial parameter estimates are required.  These are taken as the optimised\index{optimise} model parameters.  An alternative is to use a grid search for each simulation to generate initial estimates, however this is extremely computationally expensive.  For the case where values are calculated rather than minimised,\index{minimisation} this step should be skipped (although the results will be unaffected if this is accidentally run).


6.  Each simulation requires minimisation\index{minimisation} or calculation.  The same techniques as used in step 2, excluding the grid search when minimising, should be used for the simulations.


7.  Failed simulations are removed using the techniques of model elimination.\index{model elimination}\index{model elimination}


8.  The model parameter errors are calculated from the distribution of simulation parameters.


Monte Carlo simulations can be turned on or off using functions within this class.  Once the function for setting up simulations has been called, simulations will be turned on.  The effect of having simulations turned on is that the functions used for minimisation\index{minimisation} (grid search, minimise,\index{minimisation} etc) or calculation will only affect the simulation parameters and not the model parameters.  By subsequently turning simulations off using the appropriate function, the functions used in minimisation\index{minimisation} will affect the model parameters and not the simulation parameters.


An example, for model-free analysis, which includes only the functions required for implementing the above steps is:


\example{relax> grid\_search(`m1', inc=11)                                 \# Step 2.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 2.}

\example{relax> monte\_carlo.setup(`m1', number=500)                       \# Step 3.}

\example{relax> monte\_carlo.create\_data(`m1', method=`back\_calc')         \# Step 4.}

\example{relax> monte\_carlo.initial\_values(`m1')                          \# Step 5.}

\example{relax> minimise(`newton', run=`m1')                              \# Step 6.}

\example{relax> eliminate(`m1')                                           \# Step 7.}

\example{relax> monte\_carlo.error\_analysis(`m1')                          \# Step 8.}

An example for reduced spectral density mapping\index{map} is:


\example{relax> calc(`600MHz')                                            \# Step 2.}

\example{relax> monte\_carlo.setup(`600MHz', number=500)                   \# Step 3.}

\example{relax> monte\_carlo.create\_data(`600MHz', method=`back\_calc')     \# Step 4.}

\example{relax> calc(`600MHz')                                            \# Step 6.}

\example{relax> monte\_carlo.error\_analysis(`600MHz')                      \# Step 8.}



\newpage

\subsection{noe.error}


\subsubsection{Synopsis}

Function for setting the errors in the reference or saturated NOE spectra.



\subsubsection{Defaults}

\textsf{\textbf{noe.error}(self, run=None, error=0.0, spectrum\_type=None, res\_num=None, res\_name=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{error:}  The error. 

\keyword{spectrum\_type:}  The type of spectrum. 

\keyword{res\_num:}  The residue number. 

\keyword{res\_name:}  The residue name. 




\subsubsection{Description}

The spectrum\_type argument can have the following values:


\begin{description}
\item[\quotecmd{ref} --]  The NOE reference spectrum. 
\item[\quotecmd{sat} --]  The NOE spectrum with proton saturation turned on. 
\end{description}


If the \quotecmd{res\_num} and \quotecmd{res\_name} arguments are left as the defaults of None, then the error value for all residues will be set to the supplied value.  Otherwise the residue number can be set to either an integer for selecting a single residue or a python\index{Python} regular expression\index{regular expression} string for selecting multiple residues.  The residue name argument must be a string and can use regular expression\index{regular expression} as well.




\newpage

\subsection{noe.read}


\subsubsection{Synopsis}

Function for reading\index{read} peak intensities from a file for NOE calculations.



\subsubsection{Defaults}

\textsf{\textbf{noe.read}(self, run=None, file=None, dir=None, spectrum\_type=None, format=`sparky', heteronuc=`N', proton=`HN', int\_col=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{file:}  The name of the file containing the sequence\index{sequence} data. 

\keyword{dir:}  The directory where the file is located. 

\keyword{spectrum\_type:}  The type of spectrum. 

\keyword{format:}  The type of file containing peak intensities. 

\keyword{heteronuc:}  The name of the heteronucleus as specified in the peak intensity file. 

\keyword{proton:}  The name of the proton as specified in the peak intensity file. 

\keyword{int\_col:}  The column containing the peak intensity data (for a non-standard formatted file). 




\subsubsection{Description}

The peak intensity can either be from peak heights or peak volumes.


The \quotecmd{spectrum\_type} argument can have the following values:


\begin{description}
\item[\quotecmd{ref} --]  The NOE reference spectrum. 
\item[\quotecmd{sat} --]  The NOE spectrum with proton saturation turned on. 
\end{description}


The \quotecmd{format} argument can currently be set to:


\begin{itemize}
\item[] \quotecmd{sparky} 
\item[] \quotecmd{xeasy} 
\end{itemize}


If the \quotecmd{format} argument is set to \quotecmd{sparky}, the file should be a Sparky\index{Sparky, the program} peak list saved after typing the command \quotecmd{lt}.  The default is to assume that columns 0, 1, 2, and 3 (1$^\mathrm{st}$, 2$^\mathrm{nd}$, 3$^\mathrm{rd}$, and 4$^\mathrm{th}$) contain the Sparky\index{Sparky, the program} assignment, w1, w2, and peak intensity data respectively.  The frequency data w1 and w2 are ignored while the peak intensity data can either be the peak height or volume displayed\index{display} by changing the window options.  If the peak intensity data is not within column 3, set the argument \quotecmd{int\_col} to the appropriate value (column numbering starts from 0 rather than 1).


If the \quotecmd{format} argument is set to \quotecmd{xeasy}, the file should be the saved XEasy text window output of the list peak entries command, \quotecmd{tw} followed by \quotecmd{le}.  As the columns are fixed, the peak intensity column is hardwired to number 10 (the 11$^\mathrm{th}$ column) which contains either the peak height or peak volume data.  Because the columns are fixed, the \quotecmd{int\_col} argument will be ignored.


The \quotecmd{heteronuc} and \quotecmd{proton} arguments should be set respectively to the name of the heteronucleus and proton in the file.  Only those lines which match these labels will be used.



\subsubsection{Examples}

To read\index{read} the reference and saturated spectra peak heights from the Sparky\index{Sparky, the program} formatted files \quotecmd{ref.list} and \quotecmd{sat.list} to the run \quotecmd{noe}, type:


\example{relax> noe.read(`noe', file=`ref.list', spectrum\_type=`ref')}

\example{relax> noe.read(`noe', file=`sat.list', spectrum\_type=`sat')}

To read\index{read} the reference and saturated spectra peak heights from the XEasy formatted files \quotecmd{ref.text} and \quotecmd{sat.text} to the run \quotecmd{noe}, type:


\example{relax> noe.read(`noe', file=`ref.text', spectrum\_type=`ref', format=`xeasy')}

\example{relax> noe.read(`noe', file=`sat.text', spectrum\_type=`sat', format=`xeasy')}



\newpage

\subsection{nuclei}


\subsubsection{Synopsis}

Function for setting the gyromagnetic ratio of the heteronucleus.



\subsubsection{Defaults}

\textsf{\textbf{nuclei}(self, heteronuc=`N')}


\subsubsection{Keyword arguments}

\keyword{heteronuc:}  The type of heteronucleus. 




\subsubsection{Description}

The heteronuc argument can be set to the following strings:


\begin{description}
\item[N --]  Nitrogen, -2.7126e7 
\item[C --]  Carbon, 2.2e7 
\end{description}




\newpage

\subsection{palmer.create}


\subsubsection{Synopsis}

Function for creating the Modelfree4 input files.



\subsubsection{Defaults}

\textsf{\textbf{palmer.create}(self, run=None, dir=None, force=0, diff\_search=`none', sims=0, sim\_type=`pred', trim=0, steps=20, constraints=1, nucleus=`15N', atom1=`N', atom2=`H')}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{dir:}  The directory to place the files.  The default is the value of \quotecmd{run}. 

\keyword{force:}  A flag which if set to 1 will cause the results file to be overwritten if it already exists. 

\keyword{diff\_search:}  See the Modelfree4 manual for \quotecmd{diffusion\_search}. 

\keyword{sims:}  The number of Monte Carlo simulations. 

\keyword{sim\_type:}  See the Modelfree4 manual. 

\keyword{trim:}  See the Modelfree4 manual. 

\keyword{steps:}  See the Modelfree4 manual. 

\keyword{constraints:}  A flag specifying whether the parameters should be constrained.  The default is to turn constraints\index{constraint} on (constraints=1). 

\keyword{nucleus:}  A three letter string describing the nucleus type, ie 15N, 13C, etc. 

\keyword{atom1:}  The symbol of the X nucleus in the pdb file. 

\keyword{atom2:}  The symbol of the H nucleus in the pdb file. 




\subsubsection{Description}

The following files are created


\begin{itemize}
\item[] \quotecmd{dir/mfin}, 
\item[] \quotecmd{dir/mfdata}, 
\item[] \quotecmd{dir/mfpar}, 
\item[] \quotecmd{dir/mfmodel}, 
\item[] \quotecmd{dir/run.sh}. 
\end{itemize}


The file \quotecmd{run/run.sh} contains the single command,


\quotecmd{modelfree4 -i mfin -d mfdata -p mfpar -m mfmodel -o mfout -e out},


which can be used to execute modelfree4.




\newpage

\subsection{palmer.execute}


\subsubsection{Synopsis}

Function for executing Modelfree4.



\subsubsection{Defaults}

\textsf{\textbf{palmer.execute}(self, run=None, dir=None, force=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{dir:}  The directory to place the files.  The default is the value of \quotecmd{run}. 

\keyword{force:}  A flag which if set to 1 will cause the results file to be overwritten if it already exists. 




\subsubsection{Description}

Modelfree 4 will be executed as


\quotecmd{modelfree4 -i mfin -d mfdata -p mfpar -m mfmodel -o mfout -e out}


If a PDB\index{PDB} file is loaded and non-isotropic diffusion is selected, then the file name will be placed on the command line as \quotecmd{-s pdb\_file\_name}.




\newpage

\subsection{palmer.extract}


\subsubsection{Synopsis}

Function for extracting data from the Modelfree4 \quotecmd{mfout} star formatted file.



\subsubsection{Defaults}

\textsf{\textbf{palmer.extract}(self, run=None, dir=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{dir:}  The directory where the file \quotecmd{mfout} is found.  The default is the value of \quotecmd{run}. 





\newpage

\subsection{pdb}


\subsubsection{Synopsis}

The pdb loading function.



\subsubsection{Defaults}

\textsf{\textbf{pdb}(self, run=None, file=None, dir=None, model=None, heteronuc=`N', proton=`H', load\_seq=1)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The run to assign the structure to. 

\keyword{file:}  The name of the PDB\index{PDB} file. 

\keyword{dir:}  The directory where the file is located. 

\keyword{model:}  The PDB\index{PDB} model number. 

\keyword{heteronuc:}  The name of the heteronucleus as specified in the PDB\index{PDB} file. 

\keyword{proton:}  The name of the proton as specified in the PDB\index{PDB} file. 

\keyword{load\_seq:}  A flag specifying whether the sequence\index{sequence} should be loaded from the PDB\index{PDB} file. 




\subsubsection{Description}

To load a specific model from the PDB\index{PDB} file, set the model flag to an integer $i$.  The structure beginning with the line \quotecmd{MODEL $i$} in the PDB\index{PDB} file will be loaded.  Otherwise all structures will be loaded starting from the model number 1.


To load the sequence\index{sequence} from the PDB\index{PDB} file, set the \quotecmd{load\_seq} flag to 1.  If the sequence\index{sequence} has previously been loaded, then this flag will be ignored.


Once the PDB\index{PDB} structures are loaded, unit XH bond vectors will be calculated.  The vectors are calculated using the atomic coordinates of the atoms specified by the arguments heteronuc and proton.  If more than one model structure is loaded, the unit XH vectors for each model will be calculated and the final unit XH vector will be taken as the average.



\subsubsection{Example}

To load all structures from the PDB\index{PDB} file \quotecmd{test.pdb} in the directory \quotecmd{\~{}/pdb} for use in the model-free analysis run \quotecmd{m8} where the heteronucleus in the PDB\index{PDB} file is \quotecmd{N} and the proton is \quotecmd{H}, type:


\example{relax> pdb(`m8', `test.pdb', `\~{}/pdb', 1, `N', `H')}

\example{relax> pdb(run=`m8', file=`test.pdb', dir=`pdb', model=1, heteronuc=`N', proton=`H')}

To load the 10$^\mathrm{th}$ model from the file \quotecmd{test.pdb}, use:


\example{relax> pdb(`m1', `test.pdb', model=10)}

\example{relax> pdb(run=`m1', file=`test.pdb', model=10)}



\newpage

\subsection{relax\_data.back\_calc}


\subsubsection{Synopsis}

Function for back calculating relaxation\index{relaxation} data.



\subsubsection{Defaults}

\textsf{\textbf{relax\_data.back\_calc}(self, run=None, ri\_label=None, frq\_label=None, frq=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{ri\_label:}  The relaxation\index{relaxation} data type, ie \quotecmd{R1}, \quotecmd{R2}, or \quotecmd{NOE}. 

\keyword{frq\_label:}  The field strength label. 

\keyword{frq:}  The spectrometer frequency in Hz. 





\newpage

\subsection{relax\_data.copy}


\subsubsection{Synopsis}

Function for copying\index{copy} relaxation\index{relaxation} data from run1 to run2.



\subsubsection{Defaults}

\textsf{\textbf{relax\_data.copy}(self, run1=None, run2=None, ri\_label=None, frq\_label=None)}


\subsubsection{Keyword Arguments}

\keyword{run1:}  The name of the run to copy\index{copy} the sequence\index{sequence} from. 

\keyword{run2:}  The name of the run to copy\index{copy} the sequence\index{sequence} to. 

\keyword{ri\_label:}  The relaxation\index{relaxation} data type, ie \quotecmd{R1}, \quotecmd{R2}, or \quotecmd{NOE}. 

\keyword{frq\_label:}  The field strength label. 




\subsubsection{Description}

This function will copy\index{copy} relaxation\index{relaxation} data from \quotecmd{run1} to \quotecmd{run2}.  If ri\_label and frq\_label are not given then all relaxation\index{relaxation} data will be copied, otherwise only a specific data set will be copied.



\subsubsection{Examples}

To copy\index{copy} all relaxation\index{relaxation} data from run \quotecmd{m1} to run \quotecmd{m9}, type one of:


\example{relax> relax\_data.copy(`m1', `m9')}

\example{relax> relax\_data.copy(run1=`m1', run2=`m9')}

\example{relax> relax\_data.copy(`m1', `m9', None, None)}

\example{relax> relax\_data.copy(run1=`m1', run2=`m9', ri\_label=None, frq\_label=None)}

To copy\index{copy} only the NOE relaxation\index{relaxation} data with the frq\_label of \quotecmd{800} from \quotecmd{m3} to \quotecmd{m6}, type one of:


\example{relax> relax\_data.copy(`m3', `m6', `NOE', `800')}

\example{relax> relax\_data.copy(run1=`m3', run2=`m6', ri\_label=`NOE', frq\_label=`800')}



\newpage

\subsection{relax\_data.delete}


\subsubsection{Synopsis}

Function for deleting the relaxation\index{relaxation} data corresponding to ri\_label and frq\_label.



\subsubsection{Defaults}

\textsf{\textbf{relax\_data.delete}(self, run=None, ri\_label=None, frq\_label=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{ri\_label:}  The relaxation\index{relaxation} data type, ie \quotecmd{R1}, \quotecmd{R2}, or \quotecmd{NOE}. 

\keyword{frq\_label:}  The field strength label. 




\subsubsection{Examples}

To delete\index{delete} the relaxation\index{relaxation} data corresponding to ri\_label=\quotecmd{NOE}, frq\_label=\quotecmd{600}, and the run \quotecmd{m4}, type:


\example{relax> relax\_data.delete(`m4', `NOE', `600')}



\newpage

\subsection{relax\_data.display}


\subsubsection{Synopsis}

Function for displaying\index{display} the relaxation\index{relaxation} data corresponding to ri\_label and frq\_label.



\subsubsection{Defaults}

\textsf{\textbf{relax\_data.display}(self, run=None, ri\_label=None, frq\_label=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{ri\_label:}  The relaxation\index{relaxation} data type, ie \quotecmd{R1}, \quotecmd{R2}, or \quotecmd{NOE}. 

\keyword{frq\_label:}  The field strength label. 




\subsubsection{Examples}

To display\index{display} the NOE relaxation\index{relaxation} data at 600 MHz from the run \quotecmd{m4}, type


\example{relax> relax\_data.display(`m4', `NOE', `600')}



\newpage

\subsection{relax\_data.read}


\subsubsection{Synopsis}

Function for reading\index{read} R$_1$, R$_1$, or NOE relaxation\index{relaxation} data from a file.



\subsubsection{Defaults}

\textsf{\textbf{relax\_data.read}(self, run=None, ri\_label=None, frq\_label=None, frq=None, file=None, dir=None, num\_col=0, name\_col=1, data\_col=2, error\_col=3, sep=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{ri\_label:}  The relaxation\index{relaxation} data type, ie \quotecmd{R1}, \quotecmd{R2}, or \quotecmd{NOE}. 

\keyword{frq\_label:}  The field strength label. 

\keyword{frq:}  The spectrometer frequency in Hz. 

\keyword{file:}  The name of the file containing the relaxation\index{relaxation} data. 

\keyword{dir:}  The directory where the file is located. 

\keyword{num\_col:}  The residue number column (the default is 0, ie the first column). 

\keyword{name\_col:}  The residue name column (the default is 1). 

\keyword{data\_col:}  The relaxation\index{relaxation} data column (the default is 2). 

\keyword{error\_col:}  The experimental error column (the default is 3). 

\keyword{sep:}  The column separator (the default is white space). 




\subsubsection{Description}

The frequency label argument can be anything as long as data collected at the same field strength have the same label.



\subsubsection{Examples}

The following commands will read\index{read} the NOE relaxation\index{relaxation} data collected at 600 MHz out of a file called \quotecmd{noe.600.out} where the residue numbers, residue names, data, errors are in the first, second, third, and forth columns respectively.


\example{relax> relax\_data.read(`m1', `NOE', `600', 599.7 * 1e6, `noe.600.out')}

\example{relax> relax\_data.read(`m1', ri\_label=`NOE', frq\_label=`600', frq=600.0 * 1e6, file=`noe.600.out')}

The following commands will read\index{read} the R$_1$ data out of the file \quotecmd{r2.out} where the residue numbers, residue names, data, errors are in the second, third, fifth, and sixth columns respectively.  The columns are separated by commas.


\example{relax> relax\_data.read(`m1', `R2', `800 MHz', 8.0 * 1e8, `r2.out', 1, 2, 4, 5, `,')}

\example{relax> relax\_data.read(`m1', ri\_label=`R2', frq\_label=`800 MHz', frq=8.0*1e8, file=`r2.out', num\_col=1, name\_col=2, data\_col=4, error\_col=5, sep=`,')}

The following commands will read\index{read} the R$_1$ data out of the file \quotecmd{r1.out} where the columns are separated by the symbol \quotecmd{\%}


\example{relax> relax\_data.read(`m1', `R1', `300', 300.1 * 1e6, `r1.out', sep=`\%')}



\newpage

\subsection{relax\_data.write}


\subsubsection{Synopsis}

Function for writing R$_1$, R$_1$, or NOE relaxation\index{relaxation} data to a file.



\subsubsection{Defaults}

\textsf{\textbf{relax\_data.write}(self, run=None, ri\_label=None, frq\_label=None, file=None, dir=None, force=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{ri\_label:}  The relaxation\index{relaxation} data type, ie \quotecmd{R1}, \quotecmd{R2}, or \quotecmd{NOE}. 

\keyword{frq\_label:}  The field strength label. 

\keyword{file:}  The name of the file. 

\keyword{dir:}  The directory name. 

\keyword{force:}  A flag which, if set to 1, will cause the file to be overwritten. 




\subsubsection{Description}

If no directory name is given, the file will be placed in the current working directory. The \quotecmd{ri\_label} and \quotecmd{frq\_label} arguments are required for selecting which relaxation\index{relaxation} data to write\index{write} to file.




\newpage

\subsection{relax\_fit.read}


\subsubsection{Synopsis}

Function for reading\index{read} peak intensities from a file.



\subsubsection{Defaults}

\textsf{\textbf{relax\_fit.read}(self, run=None, file=None, dir=None, relax\_time=0.0, fit\_type=`exp', format=`sparky', heteronuc=`N', proton=`HN', int\_col=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{file:}  The name of the file containing the sequence\index{sequence} data. 

\keyword{dir:}  The directory where the file is located. 

\keyword{relax\_time:}  The time, in seconds, of the relaxation\index{relaxation} period. 

\keyword{fit\_type:}  The type of relaxation\index{relaxation} curve to fit. 

\keyword{format:}  The type of file containing peak intensities. 

\keyword{heteronuc:}  The name of the heteronucleus as specified in the peak intensity file. 

\keyword{proton:}  The name of the proton as specified in the peak intensity file. 

\keyword{int\_col:}  The column containing the peak intensity data (for a non-standard formatted file). 




\subsubsection{Description}

The peak intensity can either be from peak heights or peak volumes.


The supported relaxation\index{relaxation} experiments include the default two parameter exponential fit, selected by setting the \quotecmd{fit\_type} argument to \quotecmd{exp}, and the three parameter inversion recovery experiment in which the peak intensity limit\index{parameter!limit} is a non-zero value, selected by setting the argument to \quotecmd{inv}.


The format argument can currently be set to:


\begin{itemize}
\item[] \quotecmd{sparky} 
\item[] \quotecmd{xeasy} 
\end{itemize}


If the format argument is set to \quotecmd{sparky}, the file should be a Sparky\index{Sparky, the program} peak list saved after typing the command \quotecmd{lt}.  The default is to assume that columns 0, 1, 2, and 3 (1$^\mathrm{st}$, 2$^\mathrm{nd}$, 3$^\mathrm{rd}$, and 4$^\mathrm{th}$) contain the Sparky\index{Sparky, the program} assignment, w1, w2, and peak intensity data respectively. The frequency data w1 and w2 are ignored while the peak intensity data can either be the peak height or volume displayed\index{display} by changing the window options.  If the peak intensity data is not within column 3, set the argument int\_col to the appropriate value (column numbering starts from 0 rather than 1).


If the format argument is set to \quotecmd{xeasy}, the file should be the saved XEasy text window output of the list peak entries command, \quotecmd{tw} followed by \quotecmd{le}.  As the columns are fixed, the peak intensity column is hardwired to number 10 (the 11$^\mathrm{th}$ column) which contains either the peak height or peak volume data.  Because the columns are fixed, the int\_col argument will be ignored.


The heteronuc and proton arguments should be set respectively to the name of the heteronucleus and proton in the file.  Only those lines which match these labels will be used.




\newpage

\subsection{results.display}


\subsubsection{Synopsis}

Function for displaying\index{display} the results of the run.



\subsubsection{Defaults}

\textsf{\textbf{results.display}(self, run=None, format=`columnar')}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{format:}  The format of the output. 





\newpage

\subsection{results.read}


\subsubsection{Synopsis}

Function for reading\index{read} results from a file.



\subsubsection{Defaults}

\textsf{\textbf{results.read}(self, run=None, file=`results', dir=`run', format=`columnar')}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{file:}  The name of the file to read\index{read} results from. 

\keyword{dir:}  The directory where the file is located. 




\subsubsection{Description}

If no directory name is given, the results file will be searched for in a directory named after the run name.  To search for the results file in the current working directory, set dir to None.


This function is able to handle uncompressed,\index{compression!uncompressed} bzip2\index{compression!bzip2} compressed files, or gzip\index{compression!gzip} compressed files automatically.  The full file name including extension can be supplied, however, if the file cannot be found, this function will search for the file name with \quotecmd{.bz2} appended followed by the file name with \quotecmd{.gz} appended.




\newpage

\subsection{results.write}


\subsubsection{Synopsis}

Function for writing results of the run to a file.



\subsubsection{Defaults}

\textsf{\textbf{results.write}(self, run=None, file=`results', dir=`run', force=0, format=`columnar', compress\_type=1)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{file:}  The name of the file to output results to.  The default is \quotecmd{results}. 

\keyword{dir:}  The directory name. 

\keyword{force:}  A flag which, if set to 1, will cause the results file to be overwritten. 

\keyword{format:}  The format of the output. 

\keyword{compress\_type:}  The type of compression\index{compression} to use when creating the file. 




\subsubsection{Description}

If no directory name is given, the results file will be placed in a directory named after the run name.  To place the results file in the current working directory, set dir to None.


The default behaviour of this function is to compress the file using bzip2\index{compression!bzip2} compression.\index{compression}  If the extension \quotecmd{.bz2} is not included in the file name, it will be added.  The compression\index{compression} can, however, be changed to either no compression\index{compression} or gzip\index{compression!gzip} compression.\index{compression}  This is controlled by the compress\_type argument which can be set to


\begin{description}
\item[0 --]  No compression\index{compression} (no file extension), 
\item[1 --]  bzip2\index{compression!bzip2} compression\index{compression} (\quotecmd{.bz2} file extension), 
\item[2 --]  gzip\index{compression!gzip} compression\index{compression} (\quotecmd{.gz} file extension). 
\end{description}


The complementary read\index{read} function will automatically handle the compressed files.




\newpage

\subsection{run.create}


\subsubsection{Synopsis}

Function for setting up a run type.



\subsubsection{Defaults}

\textsf{\textbf{run.create}(self, run=None, run\_type=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{type:}  The type of run. 




\subsubsection{Description}

The run name can be any string however the run type can only be one of the following


\begin{description}
\item[\quotecmd{jw} --]  Reduced spectral density mapping,\index{map} 
\item[\quotecmd{mf} --]  Model-free analysis, 
\item[\quotecmd{noe} --]  Steady state NOE calculation, 
\item[\quotecmd{relax\_fit} --]  Relaxation\index{relaxation} curve fitting, 
\item[\quotecmd{srls} --]  SRLS analysis. 
\end{description}



\subsubsection{Examples}

To set up a model-free analysis run with the name \quotecmd{m5}, type:


\example{relax> run.create(`m5', `mf')}



\newpage

\subsection{run.delete}


\subsubsection{Synopsis}

Function for deleting a run.



\subsubsection{Defaults}

\textsf{\textbf{run.delete}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Description}

This function will destroy all data corresponding to the given run.




\newpage

\subsection{select.all}


\subsubsection{Synopsis}

Function for selecting all residues.



\subsubsection{Defaults}

\textsf{\textbf{select.all}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 




\subsubsection{Examples}

To select all residues for all runs type:


\example{relax> select.all()}

To select all residues for the run \quotecmd{srls\_m1}, type:


\example{relax> select.all(`srls\_m1')}

\example{relax> select.all(run=`srls\_m1')}



\newpage

\subsection{select.read}


\subsubsection{Synopsis}

Function for selecting the residues contained in a file.



\subsubsection{Defaults}

\textsf{\textbf{select.read}(self, run=None, file=None, dir=None, change\_all=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 

\keyword{file:}  The name of the file containing the list of residues to select. 

\keyword{dir:}  The directory where the file is located. 

\keyword{change\_all:}  A flag specifying if all other residues should be changed. 




\subsubsection{Description}

The file must contain one residue number per line.  The number is taken as the first column of the file and all other columns are ignored.  Empty lines and lines beginning with a hash are ignored.


The \quotecmd{change\_all} flag argument default is zero meaning that all residues currently either selected or unselected will remain that way.  Setting the argument to 1 will cause all residues not specified in the file to be unselected.



\subsubsection{Examples}

To select all residues in the file \quotecmd{isolated\_peaks}, type:


\example{relax> select.read(`noe', `isolated\_peaks')}

\example{relax> select.read(run=`noe', file=`isolated\_peaks')}



\newpage

\subsection{select.res}


\subsubsection{Synopsis}

Function for selecting specific residues.



\subsubsection{Defaults}

\textsf{\textbf{select.res}(self, run=None, num=None, name=None, change\_all=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 

\keyword{num:}  The residue number. 

\keyword{name:}  The residue name. 

\keyword{change\_all:}  A flag specifying if all other residues should be changed. 




\subsubsection{Description}

The residue number can be either an integer for selecting a single residue or a python\index{Python} regular expression,\index{regular expression} in string form, for selecting multiple residues.  For details about using regular expression,\index{regular expression} see the python\index{Python} documentation for the module \quotecmd{re}.


The residue name argument must be a string.  Regular expression\index{regular expression} is also allowed.


The \quotecmd{change\_all} flag argument default is zero meaning that all residues currently either selected or unselected will remain that way.  Setting the argument to 1 will cause all residues not specified by \quotecmd{num} or \quotecmd{name} to become unselected.



\subsubsection{Examples}

To select only glycines and alanines for the run \quotecmd{m3}, assuming they have been loaded with the names GLY and ALA, type:


\example{relax> select.res(run=`m3', name=`GLY|ALA', change\_all=1)}

\example{relax> select.res(run=`m3', name=`[GA]L[YA]', change\_all=1)}

To select residue 5 CYS in addition to the currently selected residues, type:


\example{relax> select.res(`m3', 5)}

\example{relax> select.res(`m3', 5, `CYS')}

\example{relax> select.res(`m3', `5')}

\example{relax> select.res(`m3', `5', `CYS')}

\example{relax> select.res(run=`m3', num=`5', name=`CYS')}



\newpage

\subsection{select.reverse}


\subsubsection{Synopsis}

Function for the reversal of the residue selection.



\subsubsection{Defaults}

\textsf{\textbf{select.reverse}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 




\subsubsection{Examples}

To unselect all currently selected residues and select those which are unselected type:


\example{relax> select.reverse()}



\newpage

\subsection{sequence.add\index{sequence|textbf}}


\subsubsection{Synopsis}

Function for adding a residue onto the sequence.\index{sequence}



\subsubsection{Defaults}

\textsf{\textbf{sequence.add}(self, run=None, res\_num=None, res\_name=None, select=1)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{res\_num:}  The residue number. 

\keyword{res\_name:}  The name of the residue. 

\keyword{select:}  A flag specifying if the residue should be selected. 




\subsubsection{Description}

Using this function a new sequence\index{sequence} can be generated without having to load the sequence\index{sequence} from a file.  However if the sequence\index{sequence} already exists, the new residue will be added to the end. The same residue number cannot be used more than once.



\subsubsection{Examples}

The following sequence\index{sequence} of commands will generate the sequence\index{sequence} 1 ALA, 2 GLY, 3 LYS and assign it to the run \quotecmd{m3}:


\example{relax> run = `m3'}

\example{relax> sequence.add(run, 1, `ALA')}

\example{relax> sequence.add(run, 2, `GLY')}

\example{relax> sequence.add(run, 3, `LYS')}



\newpage

\subsection{sequence.copy\index{sequence|textbf}}


\subsubsection{Synopsis}

Function for copying\index{copy} the sequence\index{sequence} from run1 to run2.



\subsubsection{Defaults}

\textsf{\textbf{sequence.copy}(self, run1=None, run2=None)}


\subsubsection{Keyword Arguments}

\keyword{run1:}  The name of the run to copy\index{copy} the sequence\index{sequence} from. 

\keyword{run2:}  The name of the run to copy\index{copy} the sequence\index{sequence} to. 




\subsubsection{Description}

This function will copy\index{copy} the sequence\index{sequence} from \quotecmd{run1} to \quotecmd{run2}.  \quotecmd{run1} must contain sequence\index{sequence} information, while \quotecmd{run2} must have no sequence\index{sequence} loaded.



\subsubsection{Examples}

To copy\index{copy} the sequence\index{sequence} from the run \quotecmd{m1} to the run \quotecmd{m2}, type:


\example{relax> sequence.copy(`m1', `m2')}

\example{relax> sequence.copy(run1=`m1', run2=`m2')}



\newpage

\subsection{sequence.delete\index{sequence|textbf}}


\subsubsection{Synopsis}

Function for deleting the sequence.\index{sequence}



\subsubsection{Defaults}

\textsf{\textbf{sequence.delete}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 




\subsubsection{Description}

This function has the same effect as using the \quotecmd{delete} function to delete\index{delete} all residue specific data.




\newpage

\subsection{sequence.display\index{sequence|textbf}}


\subsubsection{Synopsis}

Function for displaying\index{display} the sequence.\index{sequence}



\subsubsection{Defaults}

\textsf{\textbf{sequence.display}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 





\newpage

\subsection{sequence.read\index{sequence|textbf}}


\subsubsection{Synopsis}

Function for reading\index{read} sequence\index{sequence} data.



\subsubsection{Defaults}

\textsf{\textbf{sequence.read}(self, run=None, file=None, dir=None, num\_col=0, name\_col=1, sep=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{file:}  The name of the file containing the sequence\index{sequence} data. 

\keyword{dir:}  The directory where the file is located. 

\keyword{num\_col:}  The residue number column (the default is 0, ie the first column). 

\keyword{name\_col:}  The residue name column (the default is 1). 

\keyword{sep:}  The column separator (the default is white space). 




\subsubsection{Description}

If no directory is given, the file will be assumed to be in the current working directory.



\subsubsection{Examples}

The following commands will read\index{read} the sequence\index{sequence} data out of a file called \quotecmd{seq} where the residue numbers and names are in the first and second columns respectively and assign it to the run \quotecmd{m1}.


\example{relax> sequence.read(`m1', `seq')}

\example{relax> sequence.read(`m1', `seq', num\_col=0, name\_col=1)}

\example{relax> sequence.read(run=`m1', file=`seq', num\_col=0, name\_col=1, sep=None)}

The following commands will read\index{read} the sequence\index{sequence} out of the file \quotecmd{noe.out} which also contains the NOE values.


\example{relax> sequence.read(`m1', `noe.out')}

\example{relax> sequence.read(`m1', `noe.out', num\_col=0, name\_col=1)}

\example{relax> sequence.read(run=`m1', file=`noe.out', num\_col=0, name\_col=1)}

The following commands will read\index{read} the sequence\index{sequence} out of the file \quotecmd{noe.600.out} where the residue numbers are in the second column, the names are in the sixth column and the columns are separated by commas and assign it to the run \quotecmd{m5}.


\example{relax> sequence.read(`m5', `noe.600.out', num\_col=1, name\_col=5, sep=`,')}

\example{relax> sequence.read(run=`m5', file=`noe.600.out', num\_col=1, name\_col=5, sep=`,')}



\newpage

\subsection{sequence.sort\index{sequence|textbf}}


\subsubsection{Synopsis}

Function for numerically sorting the sequence\index{sequence} by residue number.



\subsubsection{Defaults}

\textsf{\textbf{sequence.sort}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 





\newpage

\subsection{sequence.write\index{sequence|textbf}}


\subsubsection{Synopsis}

Function for writing the sequence\index{sequence} to a file.



\subsubsection{Defaults}

\textsf{\textbf{sequence.write}(self, run=None, file=None, dir=None, force=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{file:}  The name of the file. 

\keyword{dir:}  The directory name. 

\keyword{force:}  A flag which, if set to 1, will cause the file to be overwritten. 




\subsubsection{Description}

If no directory name is given, the file will be placed in the current working directory.




\newpage

\subsection{state.load}


\subsubsection{Synopsis}

Function for loading a saved program state.



\subsubsection{Defaults}

\textsf{\textbf{state.load}(self, file=None, dir=None)}


\subsubsection{Keyword Arguments}

\keyword{file:}  The file name, which must be a string, of a saved program state. 

\keyword{dir:}  Directory which the file is found in. 




\subsubsection{Description}

This function is able to handle uncompressed,\index{compression!uncompressed} bzip2\index{compression!bzip2} compressed files, or gzip\index{compression!gzip} compressed files automatically.  The full file name including extension can be supplied, however, if the file cannot be found, this function will search for the file name with \quotecmd{.bz2} appended followed by the file name with \quotecmd{.gz} appended.



\subsubsection{Examples}

The following commands will load the state saved in the file \quotecmd{save}.


\example{relax> state.load(`save')}

\example{relax> state.load(file=`save')}

The following commands will load the state saved in the bzip2\index{compression!bzip2} compressed file \quotecmd{save.bz2}.


\example{relax> state.load(`save')}

\example{relax> state.load(file=`save')}

\example{relax> state.load(`save.bz2')}

\example{relax> state.load(file=`save.bz2')}



\newpage

\subsection{state.save}


\subsubsection{Synopsis}

Function for saving the program state.



\subsubsection{Defaults}

\textsf{\textbf{state.save}(self, file=None, dir=None, force=0, compress\_type=1)}


\subsubsection{Keyword Arguments}

\keyword{file:}  The file name, which must be a string, to save the current program state in. 

\keyword{dir:}  The directory to place the file in. 

\keyword{force:}  A flag which if set to 1 will cause the file to be overwritten. 




\subsubsection{Description}

The default behaviour of this function is to compress the file using bzip2\index{compression!bzip2} compression.\index{compression}  If the extension \quotecmd{.bz2} is not included in the file name, it will be added.  The compression\index{compression} can, however, be changed to either no compression\index{compression} or gzip\index{compression!gzip} compression.\index{compression}  This is controlled by the compress\_type argument which can be set to


\begin{description}
\item[0 --]  No compression\index{compression} (no file extension). 
\item[1 --]  bzip2\index{compression!bzip2} compression\index{compression} (\quotecmd{.bz2} file extension). 
\item[2 --]  gzip\index{compression!gzip} compression\index{compression} (\quotecmd{.gz} file extension). 
\end{description}



\subsubsection{Examples}

The following commands will save the current program state into the file \quotecmd{save}:


\example{relax> state.save(`save', compress\_type=0)}

\example{relax> state.save(file=`save', compress\_type=0)}

The following commands will save the current program state into the bzip2\index{compression!bzip2} compressed file \quotecmd{save.bz2}:


\example{relax> state.save(`save')}

\example{relax> state.save(file=`save')}

\example{relax> state.save(`save.bz2')}

\example{relax> state.save(file=`save.bz2')}

If the file \quotecmd{save} already exists, the following commands will save the current program state by overwriting the file.


\example{relax> state.save(`save', 1)}

\example{relax> state.save(file=`save', force=1)}



\newpage

\subsection{system}


\subsubsection{Synopsis}

Function which executes the user supplied shell command.



\subsubsection{Defaults}

\textsf{\textbf{system}(command)}



\newpage

\subsection{thread.read}


\subsubsection{Synopsis}

Function for reading\index{read} a file containing entries for each computer to run calculations on.



\subsubsection{Defaults}

\textsf{\textbf{thread.read}(self, file=`hosts', dir=`\~{}/.relax')}


\subsubsection{Keyword Arguments}

\keyword{file:}  The name of the file containing the host entries. 

\keyword{dir:}  The directory where the hosts file is located. 




\subsubsection{Description}

Certain functions within relax are coded to handle threading.  This is achieved by running multiple instances of relax on different processes or computers for each thread.  The default behaviour is that the parent instance of relax will execute all the code, however if a hosts file is read\index{read} or a hosts entry manually entered, then the threaded code will run on the specified hosts.  This function is for reading\index{read} a hosts file which should contain an an entry for each computer on which to run calculations.


For remote computers, a SSH connection will be attempted.  Public key authentication must be enabled to run calculations on remote machines so that thread can be created without asking for a password.  Details on how to do this are given below.


The format of the hosts file is as follows.  Default values are specified by placing the character \quotecmd{-} in the corresponding column.  Columns can be separated by any whitespace character, and all columns must contain an entry.  Any lines beginning with a hash will be ignored.


Column 1:  The host name or IP address of the computer on which to run a thread.


Column 2:  The login name of the user on the remote machine.  The default is to use the same name as the current user.


Column 3:  The full program path.  The default is to run \quotecmd{relax}.  This only works if relax can be found in the environmental variable \$PATH, as alias are not recognised.


Column 4:  The working directory where thread specific files are stored.  The default is \quotecmd{\~{}/.relax} where the tilde \quotecmd{\~{}} symbol represents the user's home directory on the remote machine.


Column 5:  The priority value for running the program.  The default is 15.  The remote instances of relax will be niced to this value.


Column 6:  The number of CPU or CPU cores on the machine.  The default is 1.  A thread is started for each CPU.


An example is:


{\footnotesize \begin{verbatim}
# Host          User name       Program path            Working directory    Priority  CPUs
localhost       -               -                       -                    0         2
192.168.0.10    dauvergne       /usr/local/bin/relax    -                    -         -
192.168.0.11    edward          -                       -                    -         -
\end{verbatim}}

In this case, two threads will be run on the parent computer which would be either a dual CPU system or a dual core \quotecmd{Hyper threaded} Pentium processor.  These threads will have the highest level user priority of 0.  The other two machines will have single threads running with a low priority of 15.


Once threading is enabled, to allow calculations to run on the parent machine a \quotecmd{localhost} entry should be included.


If the keyword argument \quotecmd{dir} is set to None, the hosts file will be assumed to be in the current working directory.



\subsubsection{SSH Public Key Authentication}

To enable SSH Public Key Authentication for the use of ssh, sftp, and scp without having to type a password, use the following steps.  This is essential for running a thread on a remote machine.


If the files \quotecmd{id\_rsa} and \quotecmd{id\_rsa.pub} do not exist in the directory \quotecmd{\~{}/.ssh}, type:


\example{\$ ssh-keygen -t rsa}

Press enter three times when asked for input.  This will generate the two identification files.  Then, to copy\index{copy} the public key into the \quotecmd{authorized\_keys} file on the remote machine, type:


\example{\$ ssh zucchini "echo \$(cat \~{}/.ssh/id\_rsa.pub) >> \~{}/.ssh/authorized\_keys"}

Make sure you replace \quotecmd{zucchini} with the name or IP address of the remote machine.  To use DSA rather than RSA authentication, replace \quotecmd{rsa} with \quotecmd{dsa} in the above commands. Normally the sshd keyword StrictModes, which is found in the file \quotecmd{/etc/ssh/sshd\_config}, is set to \quotecmd{yes} or, if unspecified, defaults to \quotecmd{yes}.  In this case, public key authentication may fail as the permissions of the remote file \quotecmd{\~{}/.ssh/authorized\_keys} may be too permissive.  The file should only be read/write\index{read} for the user, ie 600.  To remotely change the permissions, type:


\example{\$ ssh zucchini "chmod 600 \~{}/.ssh/authorized\_keys"}

One last keyword may need to be changed in the file \quotecmd{/etc/ssh/sshd\_config}.  If the keyword PubkeyAuthentication is set to \quotecmd{no}, change this to \quotecmd{yes}.  The default is yes, so if the keyword is missing or is commented out, nothing needs to be done.


Public key authentication should now work.  To test, type:


\example{\$ ssh zucchini}

This should securely login into the remote machine without asking for a password.  If a password prompt appears, check all the permissions on the directory \quotecmd{\~{}/.ssh} and all files within or set the sshd\_config keyword StrictModes to \quotecmd{no}.


\example{\$ ssh zucchini "chmod 700 \~{}/.ssh/"}

\example{\$ ssh zucchini "chmod 600 \~{}/.ssh/*"}

\example{\$ ssh zucchini "chmod 644 \~{}/.ssh/*.pub"}

Finally, if all else fails, make sure the three lines


{\footnotesize \begin{verbatim}
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys
\end{verbatim}}

of the file \quotecmd{sshd\_config} found within the directory \quotecmd{/etc/ssh/} are uncommented and not set to \quotecmd{no} or the \quotecmd{AuthorizedKeysFile} set to another file name.




\newpage

\subsection{unselect.all}


\subsubsection{Synopsis}

Function for unselecting all residues.



\subsubsection{Defaults}

\textsf{\textbf{unselect.all}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 




\subsubsection{Examples}

To unselect all residues type:


\example{relax> unselect.all()}

To unselect all residues for the run \quotecmd{srls\_m1}, type:


\example{relax> select.all(`srls\_m1')}

\example{relax> select.all(run=`srls\_m1')}



\newpage

\subsection{unselect.read}


\subsubsection{Synopsis}

Function for unselecting the residues contained in a file.



\subsubsection{Defaults}

\textsf{\textbf{unselect.read}(self, run=None, file=None, dir=None, change\_all=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 

\keyword{file:}  The name of the file containing the list of residues to unselect. 

\keyword{dir:}  The directory where the file is located. 

\keyword{change\_all:}  A flag specifying if all other residues should be changed. 




\subsubsection{Description}

The file must contain one residue number per line.  The number is taken as the first column of the file and all other columns are ignored.  Empty lines and lines beginning with a hash are ignored.


The \quotecmd{change\_all} flag argument default is zero meaning that all residues currently either selected or unselected will remain that way.  Setting the argument to 1 will cause all residues not specified in the file to be selected.



\subsubsection{Examples}

To unselect all overlapped residues in the file \quotecmd{unresolved}, type:


\example{relax> unselect.read(`noe', `unresolved')}

\example{relax> unselect.read(run=`noe', file=`unresolved')}



\newpage

\subsection{unselect.res}


\subsubsection{Synopsis}

Function for unselecting specific residues.



\subsubsection{Defaults}

\textsf{\textbf{unselect.res}(self, run=None, num=None, name=None, change\_all=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 

\keyword{num:}  The residue number. 

\keyword{name:}  The residue name. 

\keyword{change\_all:}  A flag specifying if all other residues should be changed. 




\subsubsection{Description}

The residue number can be either an integer for unselecting a single residue or a python\index{Python} regular expression,\index{regular expression} in string form, for unselecting multiple residues.  For details about using regular expression,\index{regular expression} see the python\index{Python} documentation for the module \quotecmd{re}.


The residue name argument must be a string.  Regular expression\index{regular expression} is also allowed.


The \quotecmd{change\_all} flag argument default is zero meaning that all residues currently either selected or unselected will remain that way.  Setting the argument to 1 will cause all residues not specified by \quotecmd{num} or \quotecmd{name} to become selected.



\subsubsection{Examples}

To unselect all glycines for the run \quotecmd{m5}, type:


\example{relax> unselect.res(run=`m5', name=`GLY|ALA')}

\example{relax> unselect.res(run=`m5', name=`[GA]L[YA]')}

To unselect residue 12 MET type:


\example{relax> unselect.res(`m5', 12)}

\example{relax> unselect.res(`m5', 12, `MET')}

\example{relax> unselect.res(`m5', `12')}

\example{relax> unselect.res(`m5', `12', `MET')}

\example{relax> unselect.res(run=`m5', num=`12', name=`MET')}



\newpage

\subsection{unselect.reverse}


\subsubsection{Synopsis}

Function for the reversal of the residue selection.



\subsubsection{Defaults}

\textsf{\textbf{unselect.reverse}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run(s).  By supplying a single string, array of strings, or None, a single run, multiple runs, or all runs will be selected respectively. 




\subsubsection{Examples}

To unselect all currently selected residues and select those which are unselected type:


\example{relax> unselect.reverse()}



\newpage

\subsection{value.copy}


\subsubsection{Synopsis}

Function for copying\index{copy} residue specific data values from run1 to run2.



\subsubsection{Defaults}

\textsf{\textbf{value.copy}(self, run1=None, run2=None, data\_type=None)}


\subsubsection{Keyword Arguments}

\keyword{run1:}  The name of the run to copy\index{copy} from. 

\keyword{run2:}  The name of the run to copy\index{copy} to. 

\keyword{data\_type:}  The data type. 




\subsubsection{Description}

Only one data type may be selected, therefore the data type argument should be a string.


If this function is used to change values of previously minimised\index{minimisation} runs, then the minimisation\index{minimisation} statistics (chi-squared value, iteration count, function count, gradient count, and Hessian count) will be reset to None.



\subsubsection{Examples}

To copy\index{copy} the CSA values from the run \quotecmd{m1} to \quotecmd{m2}, type:


\example{relax> value.copy(`m1', `m2', `CSA')}


\subsubsection{Regular expression\index{regular expression|textbf}}

The python\index{Python} function \quotecmd{match}, which uses regular expression,\index{regular expression} is used to determine which data type to set values to, therefore various data\_type strings can be used to select the same data type.  Patterns used for matching for specific data types are listed below.


This is a short description of python\index{Python} regular expression,\index{regular expression} for more information see the regular expression\index{regular expression} syntax section of the Python\index{Python} Library Reference.  Some of the regular expression\index{regular expression} syntax used in this function is:


\begin{description}
\item[\quotecmd{[]} --]  A sequence\index{sequence} or set of characters to match to a single character.  For example, \quotecmd{[Ss]2} will match both \quotecmd{S2} and \quotecmd{s2}. 
\item[\quotecmd{\^{}} --]  Match the start of the string. 
\item[\quotecmd{\$} --]  Match the end of the string.  For example, \quotecmd{\^{}[Ss]2\$} will match \quotecmd{s2} but not \quotecmd{S2f} or \quotecmd{s2s}. 
\item[\quotecmd{.} --]  Match any character. 
\item[\quotecmd{x*} --]  Match the character \quotecmd{x} any number of times, for example \quotecmd{x} will match, as will \quotecmd{xxxxx} 
\item[\quotecmd{.*} --]  Match any sequence\index{sequence} of characters of any length. 
\end{description}


Importantly, do not supply a string for the data type containing regular expression.\index{regular expression}  The regular expression\index{regular expression} is implemented so that various strings can be supplied which all match the same data type.



\subsubsection{Model-free data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Local $\tau_m$ & \quotecmd{tm} & \quotecmd{\^{}tm\$} \\
 &  &  \\
Order parameter $S^2$ & \quotecmd{s2} & \quotecmd{\^{}[Ss]2\$} \\
 &  &  \\
Order parameter $S^2_f$ & \quotecmd{s2f} & \quotecmd{\^{}[Ss]2f\$} \\
 &  &  \\
Order parameter $S^2_s$ & \quotecmd{s2s} & \quotecmd{\^{}[Ss]2s\$} \\
 &  &  \\
Correlation time $\tau_e$ & \quotecmd{te} & \quotecmd{\^{}te\$} \\
 &  &  \\
Correlation time $\tau_f$ & \quotecmd{tf} & \quotecmd{\^{}tf\$} \\
 &  &  \\
Correlation time $\tau_s$ & \quotecmd{ts} & \quotecmd{\^{}ts\$} \\
 &  &  \\
Chemical exchange & \quotecmd{rex} & \quotecmd{\^{}[Rr]ex\$} or \quotecmd{[Cc]emical[ -\_][Ee]xchange} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Model-free set details}

Setting a parameter value may have no effect depending on which model-free model is chosen, for example if $S^2_f$ values and $S^2_s$ values are set but the run corresponds to model-free model \quotecmd{m4} then, because these data values are not parameters of the model, they will have no effect.


Note that the $R_{ex}$ values are scaled quadratically with field strength and should be supplied as a field strength independent value.  Use the following formula to get the correct value:


\begin{itemize}
\item[] value = $R_{ex}$ / (2.0 * $\pi$ * frequency) ** 2 
\end{itemize}


where:


\begin{itemize}
\item[] $R_{ex}$ is the chemical exchange\index{chemical exchange} value for the current frequency. 
\item[] $\pi$ is in the namespace of relax, ie just type \quotecmd{$\pi$}. 
\item[] frequency is the proton frequency corresponding to the data. 
\end{itemize}



\subsubsection{Reduced spectral density mapping\index{map|textbf} data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
$J(0)$ & \quotecmd{j0} & \quotecmd{\^{}[Jj]0\$} or \quotecmd{[Jj](0)} \\
 &  &  \\
$J(\omega_X)$ & \quotecmd{jwx} & \quotecmd{\^{}[Jj]w[Xx]\$} or \quotecmd{[Jj](w[Xx])} \\
 &  &  \\
$J(\omega_H)$ & \quotecmd{jwh} & \quotecmd{\^{}[Jj]w[Hh]\$} or \quotecmd{[Jj](w[Hh])} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Reduced spectral density mapping\index{map|textbf} set details}

In reduced spectral density mapping,\index{map} only two values can be set, the bond length\index{bond length} and CSA value.  These must be set prior to the calculation of spectral density values.




\newpage

\subsection{value.display}


\subsubsection{Synopsis}

Function for displaying\index{display} residue specific data values.



\subsubsection{Defaults}

\textsf{\textbf{value.display}(self, run=None, data\_type=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{data\_type:}  The data type. 




\subsubsection{Description}

Only one data type may be selected, therefore the data type argument should be a string.



\subsubsection{Examples}

To show all CSA values for the run \quotecmd{m1}, type:


\example{relax> value.display(`m1', `CSA')}


\subsubsection{Regular expression\index{regular expression|textbf}}

The python\index{Python} function \quotecmd{match}, which uses regular expression,\index{regular expression} is used to determine which data type to set values to, therefore various data\_type strings can be used to select the same data type.  Patterns used for matching for specific data types are listed below.


This is a short description of python\index{Python} regular expression,\index{regular expression} for more information see the regular expression\index{regular expression} syntax section of the Python\index{Python} Library Reference.  Some of the regular expression\index{regular expression} syntax used in this function is:


\begin{description}
\item[\quotecmd{[]} --]  A sequence\index{sequence} or set of characters to match to a single character.  For example, \quotecmd{[Ss]2} will match both \quotecmd{S2} and \quotecmd{s2}. 
\item[\quotecmd{\^{}} --]  Match the start of the string. 
\item[\quotecmd{\$} --]  Match the end of the string.  For example, \quotecmd{\^{}[Ss]2\$} will match \quotecmd{s2} but not \quotecmd{S2f} or \quotecmd{s2s}. 
\item[\quotecmd{.} --]  Match any character. 
\item[\quotecmd{x*} --]  Match the character \quotecmd{x} any number of times, for example \quotecmd{x} will match, as will \quotecmd{xxxxx} 
\item[\quotecmd{.*} --]  Match any sequence\index{sequence} of characters of any length. 
\end{description}


Importantly, do not supply a string for the data type containing regular expression.\index{regular expression}  The regular expression\index{regular expression} is implemented so that various strings can be supplied which all match the same data type.



\subsubsection{Model-free data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Local $\tau_m$ & \quotecmd{tm} & \quotecmd{\^{}tm\$} \\
 &  &  \\
Order parameter $S^2$ & \quotecmd{s2} & \quotecmd{\^{}[Ss]2\$} \\
 &  &  \\
Order parameter $S^2_f$ & \quotecmd{s2f} & \quotecmd{\^{}[Ss]2f\$} \\
 &  &  \\
Order parameter $S^2_s$ & \quotecmd{s2s} & \quotecmd{\^{}[Ss]2s\$} \\
 &  &  \\
Correlation time $\tau_e$ & \quotecmd{te} & \quotecmd{\^{}te\$} \\
 &  &  \\
Correlation time $\tau_f$ & \quotecmd{tf} & \quotecmd{\^{}tf\$} \\
 &  &  \\
Correlation time $\tau_s$ & \quotecmd{ts} & \quotecmd{\^{}ts\$} \\
 &  &  \\
Chemical exchange & \quotecmd{rex} & \quotecmd{\^{}[Rr]ex\$} or \quotecmd{[Cc]emical[ -\_][Ee]xchange} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Reduced spectral density mapping\index{map|textbf} data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
$J(0)$ & \quotecmd{j0} & \quotecmd{\^{}[Jj]0\$} or \quotecmd{[Jj](0)} \\
 &  &  \\
$J(\omega_X)$ & \quotecmd{jwx} & \quotecmd{\^{}[Jj]w[Xx]\$} or \quotecmd{[Jj](w[Xx])} \\
 &  &  \\
$J(\omega_H)$ & \quotecmd{jwh} & \quotecmd{\^{}[Jj]w[Hh]\$} or \quotecmd{[Jj](w[Hh])} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}




\newpage

\subsection{value.read}


\subsubsection{Synopsis}

Function for reading\index{read} residue specific data values from a file.



\subsubsection{Defaults}

\textsf{\textbf{value.read}(self, run=None, data\_type=None, file=None, num\_col=0, name\_col=1, data\_col=2, error\_col=3, sep=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{data\_type:}  The data type. 

\keyword{frq:}  The spectrometer frequency in Hz. 

\keyword{file:}  The name of the file containing the relaxation\index{relaxation} data. 

\keyword{num\_col:}  The residue number column (the default is 0, ie the first column). 

\keyword{name\_col:}  The residue name column (the default is 1). 

\keyword{data\_col:}  The relaxation\index{relaxation} data column (the default is 2). 

\keyword{error\_col:}  The experimental error column (the default is 3). 

\keyword{sep:}  The column separator (the default is white space). 




\subsubsection{Description}

Only one data type may be selected, therefore the data type argument should be a string.  If the file only contains values and no errors, set the error column argument to None.


If this function is used to change values of previously minimised\index{minimisation} runs, then the minimisation\index{minimisation} statistics (chi-squared value, iteration count, function count, gradient count, and Hessian count) will be reset to None.



\subsubsection{Examples}

To load CSA values for the run \quotecmd{m1} from the file \quotecmd{csa\_values} in the directory \quotecmd{data}, type any of the following:


\example{relax> value.read(`m1', `CSA', `data/csa\_value')}

\example{relax> value.read(`m1', `CSA', `data/csa\_value', 0, 1, 2, 3, None, 1)}

\example{relax> value.read(run=`m1', data\_type=`CSA', file=`data/csa\_value', num\_col=0, name\_col=1, data\_col=2, error\_col=3, sep=None)}


\subsubsection{Regular expression\index{regular expression|textbf}}

The python\index{Python} function \quotecmd{match}, which uses regular expression,\index{regular expression} is used to determine which data type to set values to, therefore various data\_type strings can be used to select the same data type.  Patterns used for matching for specific data types are listed below.


This is a short description of python\index{Python} regular expression,\index{regular expression} for more information see the regular expression\index{regular expression} syntax section of the Python\index{Python} Library Reference.  Some of the regular expression\index{regular expression} syntax used in this function is:


\begin{description}
\item[\quotecmd{[]} --]  A sequence\index{sequence} or set of characters to match to a single character.  For example, \quotecmd{[Ss]2} will match both \quotecmd{S2} and \quotecmd{s2}. 
\item[\quotecmd{\^{}} --]  Match the start of the string. 
\item[\quotecmd{\$} --]  Match the end of the string.  For example, \quotecmd{\^{}[Ss]2\$} will match \quotecmd{s2} but not \quotecmd{S2f} or \quotecmd{s2s}. 
\item[\quotecmd{.} --]  Match any character. 
\item[\quotecmd{x*} --]  Match the character \quotecmd{x} any number of times, for example \quotecmd{x} will match, as will \quotecmd{xxxxx} 
\item[\quotecmd{.*} --]  Match any sequence\index{sequence} of characters of any length. 
\end{description}


Importantly, do not supply a string for the data type containing regular expression.\index{regular expression}  The regular expression\index{regular expression} is implemented so that various strings can be supplied which all match the same data type.



\subsubsection{Model-free data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Local $\tau_m$ & \quotecmd{tm} & \quotecmd{\^{}tm\$} \\
 &  &  \\
Order parameter $S^2$ & \quotecmd{s2} & \quotecmd{\^{}[Ss]2\$} \\
 &  &  \\
Order parameter $S^2_f$ & \quotecmd{s2f} & \quotecmd{\^{}[Ss]2f\$} \\
 &  &  \\
Order parameter $S^2_s$ & \quotecmd{s2s} & \quotecmd{\^{}[Ss]2s\$} \\
 &  &  \\
Correlation time $\tau_e$ & \quotecmd{te} & \quotecmd{\^{}te\$} \\
 &  &  \\
Correlation time $\tau_f$ & \quotecmd{tf} & \quotecmd{\^{}tf\$} \\
 &  &  \\
Correlation time $\tau_s$ & \quotecmd{ts} & \quotecmd{\^{}ts\$} \\
 &  &  \\
Chemical exchange & \quotecmd{rex} & \quotecmd{\^{}[Rr]ex\$} or \quotecmd{[Cc]emical[ -\_][Ee]xchange} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Model-free set details}

Setting a parameter value may have no effect depending on which model-free model is chosen, for example if $S^2_f$ values and $S^2_s$ values are set but the run corresponds to model-free model \quotecmd{m4} then, because these data values are not parameters of the model, they will have no effect.


Note that the $R_{ex}$ values are scaled quadratically with field strength and should be supplied as a field strength independent value.  Use the following formula to get the correct value:


\begin{itemize}
\item[] value = $R_{ex}$ / (2.0 * $\pi$ * frequency) ** 2 
\end{itemize}


where:


\begin{itemize}
\item[] $R_{ex}$ is the chemical exchange\index{chemical exchange} value for the current frequency. 
\item[] $\pi$ is in the namespace of relax, ie just type \quotecmd{$\pi$}. 
\item[] frequency is the proton frequency corresponding to the data. 
\end{itemize}



\subsubsection{Reduced spectral density mapping\index{map|textbf} data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
$J(0)$ & \quotecmd{j0} & \quotecmd{\^{}[Jj]0\$} or \quotecmd{[Jj](0)} \\
 &  &  \\
$J(\omega_X)$ & \quotecmd{jwx} & \quotecmd{\^{}[Jj]w[Xx]\$} or \quotecmd{[Jj](w[Xx])} \\
 &  &  \\
$J(\omega_H)$ & \quotecmd{jwh} & \quotecmd{\^{}[Jj]w[Hh]\$} or \quotecmd{[Jj](w[Hh])} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Reduced spectral density mapping\index{map|textbf} set details}

In reduced spectral density mapping,\index{map} only two values can be set, the bond length\index{bond length} and CSA value.  These must be set prior to the calculation of spectral density values.




\newpage

\subsection{value.set}


\subsubsection{Synopsis}

Function for setting residue specific data values.



\subsubsection{Defaults}

\textsf{\textbf{value.set}(self, run=None, value=None, data\_type=None, res\_num=None, res\_name=None)}


\subsubsection{Keyword arguments}

\keyword{run:}  The run to assign the values to. 

\keyword{value:}  The value(s). 

\keyword{data\_type:}  The data type(s). 

\keyword{res\_num:}  The residue number. 

\keyword{res\_name:}  The residue name. 




\subsubsection{Description}

If this function is used to change values of previously minimised\index{minimisation} runs, then the minimisation\index{minimisation} statistics (chi-squared value, iteration count, function count, gradient count, and Hessian count) will be reset to None.


The value argument can be None, a single value, or an array of values while the data type argument can be None, a string, or array of strings.  The choice of which combination determines the behaviour of this function.  The following table describes what occurs in each instance.  The Value column refers to the \quotecmd{value} argument while the Type column refers to the \quotecmd{data\_type} argument.  In these columns, \quotecmd{None} corresponds to None, \quotecmd{1} corresponds to either a single value or single string, and \quotecmd{n} corresponds to either an array of values or an array of strings.


\begin{center}
\begin{tabular}{lll}
\toprule
Value & Type & Descriptio$n$ \\
\midrule
None & None & This case is used to set the model parameters prior to minimisatio$n$ or \\
 &  & calculatio$n$.  The model parameters are set to the default values. \\
 &  &  \\
1 & None & Invalid combinatio$n$. \\
 &  &  \\
$n$ & None & This case is used to set the model parameters prior to minimisatio$n$ or \\
 &  & calculatio$n$.  The length of the value array must be equal to the number \\
 &  & of model parameters for a$n$ individual residue.  The parameters will be \\
 &  & set to the corresponding number. \\
 &  &  \\
None & 1 & The data type matching the string will be set to the default value. \\
 &  &  \\
1 & 1 & The data type matching the string will be set to the supplied number. \\
 &  &  \\
$n$ & 1 & Invalid combinatio$n$. \\
 &  &  \\
None & $n$ & Each data type matching the strings will be set to the default values. \\
 &  &  \\
1 & $n$ & Each data type matching the strings will be set to the supplied number. \\
 &  &  \\
$n$ & $n$ & Each data type matching the strings will be set to the corresponding \\
 &  & number.  Both arrays must be of equal length. \\
\bottomrule
\end{tabular}
\end{center}


Residue number and name argument.


If the \quotecmd{res\_num} and \quotecmd{res\_name} arguments are left as the defaults of None, then the function will be applied to all residues.  Otherwise the residue number can be set to either an integer for selecting a single residue or a python\index{Python} regular expression\index{regular expression} string for selecting multiple residues.  The residue name argument must be a string and can use regular expression\index{regular expression} as well.



\subsubsection{Examples}

To set the parameter values for the run \quotecmd{test} to the default values, for all residues, type:


\example{relax> value.set(`test')}

To set the parameter values of residue 10, which is the model-free run \quotecmd{m4} and has the parameters \{$S^2$, $\tau_e$, $R_{ex}$\}, the following can be used.  $R_{ex}$ term is the value for the first given field strength.


\example{relax> value.set(`m4', [0.97, 2.048*1e-9, 0.149], res\_num=10)}

\example{relax> value.set(`m4', value=[0.97, 2.048*1e-9, 0.149], res\_num=10)}

To set the CSA value for the model-free run \quotecmd{tm3} to the default value, type:


\example{relax> value.set(`tm3', data\_type=`csa')}

To set the CSA value of all residues in the reduced spectral density mapping\index{map} run \quotecmd{600MHz} to -170 ppm, type:


\example{relax> value.set(`600MHz', -170 * 1e-6, `csa')}

\example{relax> value.set(`600MHz', value=-170 * 1e-6, data\_type=`csa')}

To set the NH bond length\index{bond length} of all residues in the model-free run \quotecmd{m5} to 1.02 \AA, type:


\example{relax> value.set(`m5', 1.02 * 1e-10, `bond\_length')}

\example{relax> value.set(`m5', value=1.02 * 1e-10, data\_type=`r')}

To set both the bond length\index{bond length} and the CSA value for the run \quotecmd{new} to the default values, type:


\example{relax> value.set(`new', data\_type=[`bond length', `csa'])}

To set both $\tau_f$ and $\tau_s$ in the model-free run \quotecmd{m6} to 100 ps, type:


\example{relax> value.set(`m6', 100e-12, [`tf', `ts'])}

\example{relax> value.set(`m6', value=100e-12, data\_type=[`tf', `ts'])}

To set the $S^2$ and $\tau_e$ parameter values for model-free run \quotecmd{m4} which has the parameters \{$S^2$, $\tau_e$, $R_{ex}$\} to 0.56 and 13 ps, type:


\example{relax> value.set(`m4', [0.56, 13e-12], [`S2', `te'], 10)}

\example{relax> value.set(`m4', value=[0.56, 13e-12], data\_type=[`S2', `te'], res\_num=10)}

\example{relax> value.set(run=`m4', value=[0.56, 13e-12], data\_type=[`S2', `te'], res\_num=10)}


\subsubsection{Regular expression\index{regular expression|textbf}}

The python\index{Python} function \quotecmd{match}, which uses regular expression,\index{regular expression} is used to determine which data type to set values to, therefore various data\_type strings can be used to select the same data type.  Patterns used for matching for specific data types are listed below.


This is a short description of python\index{Python} regular expression,\index{regular expression} for more information see the regular expression\index{regular expression} syntax section of the Python\index{Python} Library Reference.  Some of the regular expression\index{regular expression} syntax used in this function is:


\begin{description}
\item[\quotecmd{[]} --]  A sequence\index{sequence} or set of characters to match to a single character.  For example, \quotecmd{[Ss]2} will match both \quotecmd{S2} and \quotecmd{s2}. 
\item[\quotecmd{\^{}} --]  Match the start of the string. 
\item[\quotecmd{\$} --]  Match the end of the string.  For example, \quotecmd{\^{}[Ss]2\$} will match \quotecmd{s2} but not \quotecmd{S2f} or \quotecmd{s2s}. 
\item[\quotecmd{.} --]  Match any character. 
\item[\quotecmd{x*} --]  Match the character \quotecmd{x} any number of times, for example \quotecmd{x} will match, as will \quotecmd{xxxxx} 
\item[\quotecmd{.*} --]  Match any sequence\index{sequence} of characters of any length. 
\end{description}


Importantly, do not supply a string for the data type containing regular expression.\index{regular expression}  The regular expression\index{regular expression} is implemented so that various strings can be supplied which all match the same data type.



\subsubsection{Model-free data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Local $\tau_m$ & \quotecmd{tm} & \quotecmd{\^{}tm\$} \\
 &  &  \\
Order parameter $S^2$ & \quotecmd{s2} & \quotecmd{\^{}[Ss]2\$} \\
 &  &  \\
Order parameter $S^2_f$ & \quotecmd{s2f} & \quotecmd{\^{}[Ss]2f\$} \\
 &  &  \\
Order parameter $S^2_s$ & \quotecmd{s2s} & \quotecmd{\^{}[Ss]2s\$} \\
 &  &  \\
Correlation time $\tau_e$ & \quotecmd{te} & \quotecmd{\^{}te\$} \\
 &  &  \\
Correlation time $\tau_f$ & \quotecmd{tf} & \quotecmd{\^{}tf\$} \\
 &  &  \\
Correlation time $\tau_s$ & \quotecmd{ts} & \quotecmd{\^{}ts\$} \\
 &  &  \\
Chemical exchange & \quotecmd{rex} & \quotecmd{\^{}[Rr]ex\$} or \quotecmd{[Cc]emical[ -\_][Ee]xchange} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Model-free set details}

Setting a parameter value may have no effect depending on which model-free model is chosen, for example if $S^2_f$ values and $S^2_s$ values are set but the run corresponds to model-free model \quotecmd{m4} then, because these data values are not parameters of the model, they will have no effect.


Note that the $R_{ex}$ values are scaled quadratically with field strength and should be supplied as a field strength independent value.  Use the following formula to get the correct value:


\begin{itemize}
\item[] value = $R_{ex}$ / (2.0 * $\pi$ * frequency) ** 2 
\end{itemize}


where:


\begin{itemize}
\item[] $R_{ex}$ is the chemical exchange\index{chemical exchange} value for the current frequency. 
\item[] $\pi$ is in the namespace of relax, ie just type \quotecmd{$\pi$}. 
\item[] frequency is the proton frequency corresponding to the data. 
\end{itemize}



\subsubsection{Model-free default values}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Value \\
\midrule
Local $\tau_m$ & \quotecmd{tm} & 10 * 1e-9 \\
 &  &  \\
Order parameters $S^2$, $S^2_f$, and $S^2_s$ & \quotecmd{s2}, \quotecmd{s2f}, \quotecmd{s2s} & 0.8 \\
 &  &  \\
Correlation time $\tau_e$ & \quotecmd{te} & 100 * 1e-12 \\
 &  &  \\
Correlation time $\tau_f$ & \quotecmd{tf} & 10 * 1e-12 \\
 &  &  \\
Correlation time $\tau_s$ & \quotecmd{ts} & 1000 * 1e-12 \\
 &  &  \\
Chemical exchange relaxation\index{relaxation} & \quotecmd{rex} & 0.0 \\
 &  &  \\
Bond length & \quotecmd{r} & 1.02 * 1e-10 \\
 &  &  \\
CSA & \quotecmd{csa} & -170 * 1e-6 \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Reduced spectral density mapping\index{map|textbf} data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
$J(0)$ & \quotecmd{j0} & \quotecmd{\^{}[Jj]0\$} or \quotecmd{[Jj](0)} \\
 &  &  \\
$J(\omega_X)$ & \quotecmd{jwx} & \quotecmd{\^{}[Jj]w[Xx]\$} or \quotecmd{[Jj](w[Xx])} \\
 &  &  \\
$J(\omega_H)$ & \quotecmd{jwh} & \quotecmd{\^{}[Jj]w[Hh]\$} or \quotecmd{[Jj](w[Hh])} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Reduced spectral density mapping\index{map|textbf} set details}

In reduced spectral density mapping,\index{map} only two values can be set, the bond length\index{bond length} and CSA value.  These must be set prior to the calculation of spectral density values.



\subsubsection{Reduced spectral density mapping\index{map|textbf} default values}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Value \\
\midrule
Bond length & \quotecmd{r} & 1.02 * 1e-10 \\
 &  &  \\
CSA & \quotecmd{csa} & -170 * 1e-6 \\
\bottomrule
\end{tabular}
\end{center}




\newpage

\subsection{value.write}


\subsubsection{Synopsis}

Function for writing residue specific data values to a file.



\subsubsection{Defaults}

\textsf{\textbf{value.write}(self, run=None, data\_type=None, file=None, dir=None, force=0)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run. 

\keyword{data\_type:}  The data type. 

\keyword{file:}  The name of the file. 

\keyword{dir:}  The directory name. 

\keyword{force:}  A flag which, if set to 1, will cause the file to be overwritten. 




\subsubsection{Description}

If no directory name is given, the file will be placed in the current working directory.


The data type argument should be a string.



\subsubsection{Examples}

To write\index{write} the CSA values for the run \quotecmd{m1} to the file \quotecmd{csa.txt}, type:


\example{relax> value.write(`m1', `CSA', `csa.txt')}

\example{relax> value.write(run=`m1', data\_type=`CSA', file=`csa.txt')}

To write\index{write} the NOE values from the run \quotecmd{noe} to the file \quotecmd{noe}, type:


\example{relax> value.write(`noe', `noe', `noe.out')}

\example{relax> value.write(`noe', data\_type=`noe', file=`noe.out')}

\example{relax> value.write(run=`noe', data\_type=`noe', file=`noe.out')}

\example{relax> value.write(run=`noe', data\_type=`noe', file=`noe.out', force=1)}


\subsubsection{Regular expression\index{regular expression|textbf}}

The python\index{Python} function \quotecmd{match}, which uses regular expression,\index{regular expression} is used to determine which data type to set values to, therefore various data\_type strings can be used to select the same data type.  Patterns used for matching for specific data types are listed below.


This is a short description of python\index{Python} regular expression,\index{regular expression} for more information see the regular expression\index{regular expression} syntax section of the Python\index{Python} Library Reference.  Some of the regular expression\index{regular expression} syntax used in this function is:


\begin{description}
\item[\quotecmd{[]} --]  A sequence\index{sequence} or set of characters to match to a single character.  For example, \quotecmd{[Ss]2} will match both \quotecmd{S2} and \quotecmd{s2}. 
\item[\quotecmd{\^{}} --]  Match the start of the string. 
\item[\quotecmd{\$} --]  Match the end of the string.  For example, \quotecmd{\^{}[Ss]2\$} will match \quotecmd{s2} but not \quotecmd{S2f} or \quotecmd{s2s}. 
\item[\quotecmd{.} --]  Match any character. 
\item[\quotecmd{x*} --]  Match the character \quotecmd{x} any number of times, for example \quotecmd{x} will match, as will \quotecmd{xxxxx} 
\item[\quotecmd{.*} --]  Match any sequence\index{sequence} of characters of any length. 
\end{description}


Importantly, do not supply a string for the data type containing regular expression.\index{regular expression}  The regular expression\index{regular expression} is implemented so that various strings can be supplied which all match the same data type.



\subsubsection{Model-free data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Local $\tau_m$ & \quotecmd{tm} & \quotecmd{\^{}tm\$} \\
 &  &  \\
Order parameter $S^2$ & \quotecmd{s2} & \quotecmd{\^{}[Ss]2\$} \\
 &  &  \\
Order parameter $S^2_f$ & \quotecmd{s2f} & \quotecmd{\^{}[Ss]2f\$} \\
 &  &  \\
Order parameter $S^2_s$ & \quotecmd{s2s} & \quotecmd{\^{}[Ss]2s\$} \\
 &  &  \\
Correlation time $\tau_e$ & \quotecmd{te} & \quotecmd{\^{}te\$} \\
 &  &  \\
Correlation time $\tau_f$ & \quotecmd{tf} & \quotecmd{\^{}tf\$} \\
 &  &  \\
Correlation time $\tau_s$ & \quotecmd{ts} & \quotecmd{\^{}ts\$} \\
 &  &  \\
Chemical exchange & \quotecmd{rex} & \quotecmd{\^{}[Rr]ex\$} or \quotecmd{[Cc]emical[ -\_][Ee]xchange} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{Reduced spectral density mapping\index{map|textbf} data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
$J(0)$ & \quotecmd{j0} & \quotecmd{\^{}[Jj]0\$} or \quotecmd{[Jj](0)} \\
 &  &  \\
$J(\omega_X)$ & \quotecmd{jwx} & \quotecmd{\^{}[Jj]w[Xx]\$} or \quotecmd{[Jj](w[Xx])} \\
 &  &  \\
$J(\omega_H)$ & \quotecmd{jwh} & \quotecmd{\^{}[Jj]w[Hh]\$} or \quotecmd{[Jj](w[Hh])} \\
 &  &  \\
Bond length & \quotecmd{r} & \quotecmd{\^{}r\$} or \quotecmd{[Bb]ond[ -\_][Ll]ength} \\
 &  &  \\
CSA & \quotecmd{csa} & \quotecmd{\^{}[Cc][Ss][Aa]\$} \\
\bottomrule
\end{tabular}
\end{center}



\subsubsection{NOE calculation data type string matching patterns}

\begin{center}
\begin{tabular}{lll}
\toprule
Data type & Object name & Patterns \\
\midrule
Reference intensity & \quotecmd{ref} & \quotecmd{\^{}[Rr]ef\$} or \quotecmd{[Rr]ef[ -\_][Ii]nt} \\
 &  &  \\
Saturated intensity & \quotecmd{sat} & \quotecmd{\^{}[Ss]at\$} or \quotecmd{[Ss]at[ -\_][Ii]nt} \\
 &  &  \\
NOE & \quotecmd{noe} & \quotecmd{\^{}[Nn][Oo][Ee]\$} \\
\bottomrule
\end{tabular}
\end{center}




\newpage

\subsection{vmd.view}


\subsubsection{Synopsis}

Function for viewing the collection of molecules\index{molecule} extracted from the PDB\index{PDB} file.



\subsubsection{Defaults}

\textsf{\textbf{vmd.view}(self, run=None)}


\subsubsection{Keyword Arguments}

\keyword{run:}  The name of the run which the PDB\index{PDB} belongs to. 




\subsubsection{Example}

\example{relax> vmd.view(`m1')}

\example{relax> vmd.view(run=`pdb')}

