#! /usr/bin/python
# That line was just so programs like gvim or emacs will understand that this is Python code!  Don't
# make this file executable.

###############################################################################
#                                                                             #
# Copyright (C) 2006 Edward d'Auvergne                                        #
#                                                                             #
# This file is part of the program relax.                                     #
#                                                                             #
# relax is free software; you can redistribute it and/or modify               #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# relax is distributed in the hope that it will be useful,                    #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with relax; if not, write to the Free Software                        #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   #
#                                                                             #
###############################################################################


# Import statements.
import platform
from os import F_OK, access, getcwd, path, remove, rmdir, sep, system, walk
from re import search
from shutil import copytree
import sys
from tarfile import TarFile
from zipfile import ZipFile

# UNIX only functions from the os module.
try:
    from os import lstat, symlink
except ImportError:
    pass


# relax and Scons modules.
from scons.manuals import acro, clean_manual_files, compile_user_manual_html, compile_user_manual_pdf, fetch_docstrings, version_file
from version import version



class Main:
    def __init__(self):
        """Initialise the main building targets.
        
        This function sets up the Scons build Environments, sets custom Builders, sets the build
        targets, and sets the build dependancies.
        """

        # Initialisation.
        #################

        # Set the help message.
        self.help()

        # The operating system.
        self.SYSTEM = platform.uname()[0]

        # Set up the paths and file names.
        self.set_paths()



        # C module compilation.
        #######################

        # Setup the rules for building the relaxation curve fitting C modules (and set it as the default).
        self.relax_fit()
        Default(self.relax_fit_object)



        # Program installation.
        #######################

        # Install target.
        install_env = Environment(BUILDERS={'install' : Builder(action=self.install)},
                                  RELAX_PATH=self.RELAX_PATH)
        install_env.install(target='install', source=None)

        # Uninstall target.
        uninstall_env = Environment(BUILDERS={'uninstall' : Builder(action=self.uninstall)})
        uninstall_env.uninstall(target='uninstall', source=None)



        # Distribution packages.
        ########################

        # Target for creating the binary distribution file.
        binary_dist_env = Environment(BUILDERS={'dummy' : Builder(action=self.dummy)})
        binary_dist_env.dummy(target='binary_dist', source=None)
        binary_dist_env.Depends('binary_dist', 'version_check')           # First check the program version number.
        binary_dist_env.Depends('binary_dist', self.relax_fit_object)     # Compile the C code.
        binary_dist_env.Depends('binary_dist', 'user_manual_pdf_dist')    # Compile the PDF version of the user manual.
        binary_dist_env.Depends('binary_dist', 'manual_clean_nodeps')     # Clean up the temporary manual files.
        binary_dist_env.Depends('binary_dist', 'clean_temp')              # Then clean up all other temporary files.
        binary_dist_env.Depends('binary_dist', 'package_bin')             # Package the binary distribution.
        binary_dist_env.Depends('binary_dist', 'gpg_bin')                 # GPG sign the binary distribution file.

        # Target for creating the source distribution file.
        source_dist_env = Environment(BUILDERS={'dummy' : Builder(action=self.dummy)})
        source_dist_env.dummy(target='source_dist', source=None)
        source_dist_env.Depends('source_dist', 'version_check')           # First check the program version number.
        source_dist_env.Depends('source_dist', 'user_manual_pdf_dist')    # Compile the PDF version of the user manual.
        source_dist_env.Depends('source_dist', 'manual_clean_nodeps')     # Clean up the temporary manual files.
        source_dist_env.Depends('source_dist', 'clean')                   # Then clean up the sources.
        source_dist_env.Depends('source_dist', 'package_src')             # Package the source distribution.
        source_dist_env.Depends('source_dist', 'gpg_src')                 # GPG sign the source distribution file.

        # Target for packaging the binary distribution.
        package_bin_env = Environment(BUILDERS={'archive' : Builder(action=self.package)},
                                      DIST_FILE=self.BIN_FILE)
        package_bin_env.archive(target='package_bin', source=None)
        package_bin_env.Depends('package_bin', 'version_check')     # Check the program version number first.

        # Target for packaging the source distribution.
        package_src_env = Environment(BUILDERS={'archive' : Builder(action=self.package)},
                                      DIST_FILE=self.SRC_FILE)
        package_src_env.archive(target='package_src', source=None)
        package_src_env.Depends('package_bin', 'version_check')     # Check the program version number first.

        # Target for creating a GPG signature of the binary distribution file.
        gpg_bin_env = Environment(BUILDERS={'sign' : Builder(action=self.gpg_sign)},
                                  DIST_FILE=self.BIN_FILE)
        gpg_bin_env.sign(target='gpg_bin', source=None)
        gpg_bin_env.Depends('gpg_bin', 'version_check')     # Check the program version number before signing.

        # Target for creating a GPG signature of the source distribution file.
        gpg_src_env = Environment(BUILDERS={'sign' : Builder(action=self.gpg_sign)},
                                  DIST_FILE=self.SRC_FILE)
        gpg_src_env.sign(target='gpg_src', source=None)
        gpg_src_env.Depends('gpg_src', 'version_check')     # Check the program version number before signing.



        # relax version checking.
        #########################

        # relax version number checking target.
        version_check_env = Environment(BUILDERS={'check' : Builder(action=self.test_version)})
        version_check_env.check(target='version_check', source=None)



        # Cleaning up.
        ##############

        # Clean target.
        clean_env = Environment(BUILDERS={'clean' : Builder(action=self.clean_files)})
        clean_env.clean(target='clean', source=None)
        clean_env.Depends('clean', 'clean_temp')       # Run the 'clean_temp' target.
        clean_env.Depends('clean', 'manual_clean')     # Run the 'manual_clean' target.

        # Target for removing temporary files.
        clean_temp_env = Environment(BUILDERS={'clean' : Builder(action=self.clean_temp_files)})
        clean_temp_env.clean(target='clean_temp', source=None)



        # relax manuals.
        ################

        # Create the manual build environment.
        manual_env = Environment(DOCS_DIR=self.DOCS_DIR,
                                 LATEX_DIR=self.LATEX_DIR,
                                 SYSTEM=self.SYSTEM)


        # Set up the builder for the standard manual targets (using the self.dummy function).
        manual_env.Append(BUILDERS={'Manual' : Builder(action=self.dummy)})

        # Target for creating the PDF version of the user manual.
        manual_env.Manual(target='user_manual_pdf', source=None)
        manual_env.Depends('user_manual_pdf', 'manual_clean')
        manual_env.Depends('user_manual_pdf', 'manual_version_file')
        manual_env.Depends('user_manual_pdf', 'fetch_docstrings')
        manual_env.Depends('user_manual_pdf', 'compile_user_manual_pdf')
        manual_env.Depends('user_manual_pdf', 'manual_acro')

        # Target for creating the HTML version of the user manual.
        manual_env.Manual(target='user_manual_html', source=None)
        manual_env.Depends('user_manual_html', 'manual_clean')
        manual_env.Depends('user_manual_html', 'manual_version_file')
        manual_env.Depends('user_manual_html', 'fetch_docstrings')
        manual_env.Depends('user_manual_html', 'compile_user_manual_html')
        manual_env.Depends('user_manual_html', 'manual_acro')

        # Target for creating the PDF version of the user manual (without fetching the docstrings).
        manual_env.Manual(target='user_manual_pdf_nofetch', source=None)
        manual_env.Depends('user_manual_pdf_nofetch', 'manual_clean')
        manual_env.Depends('user_manual_pdf_nofetch', 'manual_version_file')
        manual_env.Depends('user_manual_pdf_nofetch', 'compile_user_manual_pdf')
        manual_env.Depends('user_manual_pdf_nofetch', 'manual_acro')

        # Target for creating the PDF version of the user manual for distribution.
        manual_env.Manual(target='user_manual_pdf_dist', source=None)
        manual_env.Depends('user_manual_pdf_dist', 'manual_clean')
        manual_env.Depends('user_manual_pdf_dist', 'manual_version_file')
        manual_env.Depends('user_manual_pdf_dist', 'fetch_docstrings')
        manual_env.Depends('user_manual_pdf_dist', 'compile_user_manual_pdf')

        # Target for creating relax version number LaTeX file.
        manual_env.Append(BUILDERS={'Version' : Builder(action=version_file)})
        manual_env.Version(target='manual_version_file', source=None)

        # Target for fetching the docstrings.
        manual_env.Append(BUILDERS={'Fetch' : Builder(action=fetch_docstrings)})
        manual_env.Fetch(target='fetch_docstrings', source=None)

        # Target for compiling the PDF version of the user manaul from the LaTeX sources.
        manual_env.Append(BUILDERS={'CompileUserManualPDF' : Builder(action=compile_user_manual_pdf)})
        manual_env.CompileUserManualPDF(target='compile_user_manual_pdf', source=None)

        # Target for compiling the HTML version of the user manual from the LaTeX sources.
        manual_env.Append(BUILDERS={'CompileUserManualHTML' : Builder(action=compile_user_manual_html)})
        manual_env.CompileUserManualHTML(target='compile_user_manual_html', source=None)

        # Target for launching Adobe Acrobat with the PDF version of the relax manual.
        manual_env.Append(BUILDERS={'Acro' : Builder(action=acro)})
        manual_env.Acro(target='manual_acro', source=None)

        # Clean target.
        manual_env.Append(BUILDERS={'Clean' : Builder(action=clean_manual_files)})
        manual_env.Clean(target='manual_clean', source=None)

        # Clean target (with no manual environments dependent on it).
        manual_env.Append(BUILDERS={'Clean' : Builder(action=clean_manual_files)})
        manual_env.Clean(target='manual_clean_nodeps', source=None)


    def clean_files(self, target, source, env):
        """Builder action for cleaning up."""

        # Print out.
        print
        print "###############"
        print "# Cleaning up #"
        print "###############\n\n"

        # Extensions of files to remove.
        temp_extns = ['so', 'sconsign', 'dll']

        # Print out.
        print "\nRemoving the files ending in " + `temp_extns` + ".\n"

        # Walk through the directories.
        for root, dirs, files in walk(getcwd()):
            # Loop over the files in the current directory.
            for file in files:
                # Loop over the extensions.
                for ext in temp_extns:
                    if search('\.' + ext + '$', file):
                        remove(path.join(root, file))

        # Final print out.
        print "\n\n\n"


    def clean_temp_files(self, target, source, env):
        """Builder action for removing temporary files."""

        # Print out.
        print
        print "###############################"
        print "# Cleaning up temporary files #"
        print "###############################\n\n"

        # Extensions of temporary files.
        temp_extns = ['pyc', 'bak', 'o', 'os', 'obj', 'exp', 'lib']

        # Print out.
        print "\nRemoving the files ending in " + `temp_extns` + ".\n"

        # Walk through the directories.
        for root, dirs, files in walk(getcwd()):
            # Loop over the files in the current directory.
            for file in files:
                # Loop over the extensions.
                for ext in temp_extns:
                    if search('\.' + ext + '$', file):
                        remove(path.join(root, file))

        # Final print out.
        print "\n\n\n"


    def dummy(self, target, source, env):
        """Dummy function which returns zero."""

        return 0


    def gpg_sign(self, target, source, env):
        """Builder action for creating a GPG signature of the binary distribution file."""

        # Print out.
        print
        print "############################################"
        print "# GPG signing the binary distribution file #"
        print "############################################\n\n"

        # Run the 'gpg' command.
        system("gpg --detach-sign --default-key relax " + path.pardir + path.sep + env['DIST_FILE'])

        # Final print out.
        print "\n\n\n"


    def help(self):
        """The help message."""

        # Intro.
        string = '\nSconstruct help for relax.\n\n'

        # Main text.
        string = string + 'To build the C modules, type\n\n$ scons\n\n'
        string = string + 'To install the program, type\n\n$ scons install\n\n'

        # Set the help message.
        Help(string)


    def install(self, target, source, env):
        """relax installation function (a Builder action)."""

        # Print out.
        ############

        print
        print "####################"
        print "# Installing relax #"
        print "####################\n\n"
        print "Installing the program relax into the directory " + `self.RELAX_PATH` + "\n\n"


        # Tests.
        ########

        # Test that the installation path exists.
        if not access(self.INSTALL_PATH, F_OK):
            sys.stderr.write("Cannot install relax, the installation path " + `self.INSTALL_PATH` + " does not exist.\n\n")
            return

        # Test if the binary directory already exists.
        if not access(self.BIN_PATH, F_OK):
            sys.stderr.write("Cannot install relax, the directory " + `self.BIN_PATH` + " does not exist.\n\n")
            return

        # Test if the relax installation directory already exists.
        if access(self.RELAX_PATH, F_OK):
            sys.stderr.write("Cannot install relax, the directory " + `self.RELAX_PATH` + " already exists.\n\n")
            return

        # Test if the symlink exists.
        if self.symlink_flag:
            try:
                lstat(self.SYMLINK)
            except OSError:
                # OK, symlink doesn't exist.
                pass
            else:
                sys.stderr.write("Cannot install relax, the file " + `self.SYMLINK` + " already exists.\n\n")
                return


        # Install.
        ##########

        # Copy the files (and create the directory).
        try:
            print "\nCopying all files in " + `getcwd()` + " to " + `self.RELAX_PATH` + "."
            copytree(getcwd(), self.RELAX_PATH)
        except OSError, message:
            # Failure message.
            sys.stderr.write("Cannot install relax, " + message.__doc__ + "\n")

            # You don't have the privilages to do this.
            if message.errno == 13:
                sys.stderr.write("Permission denied, cannot create the directory " + `self.RELAX_PATH` + ".\n\n")

            # All other errors (print normal python error message).
            else:
                sys.stderr.write("OSError: [Errno " + `message.errno` + "] " + message.strerror + ": " + `message.filename` + "\n\n")

            # Quit the function.
            return

        # Create the symbolic link.
        if self.symlink_flag:
            print "\nCreating the symbolic link from " + `self.RELAX_PATH + sep + 'relax'` + " to " + `self.SYMLINK` + "."
            symlink(self.RELAX_PATH + sep + 'relax', self.SYMLINK)


        # Byte compile.
        ###############

        # Run relax to create the *.pyc files.
	    print "\nRunning relax to create the byte-compiled *.pyc files."
        system(self.SYMLINK + " --test")

        # Final print out.
        print "\n\n\n"


    def relax_fit(self):
        """Function for setting up scons for building the relaxation curve fitting C modules."""

        # The directory.
        dir = 'maths_fns'

        # File names.
        files = ['c_chi2.c',
                 'exponential.c',
                 'relax_fit.c']

        # Construct the python include path (for Python.h).
        py_include_minpath = sys.prefix + path.sep + 'include'
        py_include_fullpath = py_include_minpath + path.sep + 'python' + `sys.version_info[0]` + '.' + `sys.version_info[1]`

        # C flags.
        if self.SYSTEM == 'Windows':
            cflags = '/nologo /I\"' + py_include_minpath + '\"'
        else:
            cflags = '-I' + py_include_fullpath

        # Relaxation curve fitting build environment.
        env = Environment()

        # Python library path.
        libpath = ''
        if self.SYSTEM == 'Windows':
            libpath = sys.prefix + path.sep + 'libs'

        # Add the python library path to the environment.
        env.Append(LIBPATH = libpath)

        # Catch Mac OS X and send the correct command line options to the linker.
        if env['PLATFORM'] == 'darwin':
            env.Append(LINKFLAGS = ['-bundle', '-bundle_loader', sys.prefix + path.sep + 'bin' + path.sep + 'python', '-dynamic'])

        # Loop over the relaxation curve fitting files.
        nodes = []
        for file in files:
            nodes.append(env.SharedObject(dir + path.sep + file, CCFLAGS=cflags))

        # Build the relaxation curve fitting module.
        self.relax_fit_object = env.SharedLibrary(target=dir + path.sep + 'relax_fit', source=nodes, SHLIBPREFIX='')

        # Print out string returning function.
        def print_string(target, source, env):
            string = "\n\n\n\n"
            string = string + "###########################\n"
            string = string + "# Compiling the C modules #\n"
            string = string + "###########################\n\n\n"
            string = string + "Building the relaxation curve fitting module " + `str(self.relax_fit_object[0])` + "\n"
            return string

        # Add the print out as an action to take before constructing the first object.
        env.AddPreAction(nodes[0], Action(self.dummy, print_string))


    def set_paths(self):
        """Function for setting the paths and file names."""

        # The machine type.
        self.MACH = platform.uname()[4]

        # Symbolic link flag.
        self.symlink_flag = 1

        # GNU/Linux.
        if self.SYSTEM == 'Linux':
            # System specific string.
            self.SYS = 'GNU-Linux'

            # Linux installation path.
            self.INSTALL_PATH = '/usr/local'


        # MS Windows.
        elif self.SYSTEM == 'Windows':
            # Architecture.
            arch = platform.architecture()[0]

            # 32 bit.
            if arch == '32bit':
                self.SYS = 'Win32'
            elif arch == '64bit':
                self.SYS = 'Win64'
            else:
                self.SYS = 'Win'

            # Windows installation path.
            self.INSTALL_PATH = 'C:\\'

            # No symlinks!
            self.symlink_flag = 0

        # Mac OS X.
        elif self.SYSTEM == 'Darwin':
            # System specific string.
            self.SYS = self.SYSTEM

            # Mac OS X installation path.
            self.INSTALL_PATH = sys.prefix + sep + 'local'


        # All other operating systems.
        else:
            # System specific string.
            self.SYS = self.SYSTEM

            # Installation path.
            self.INSTALL_PATH = sys.prefix + sep + 'local'



        # Installation.
        ###############
        
        # Relax installation directory.
        self.RELAX_PATH = self.INSTALL_PATH + sep + 'relax'

        # Installation path for binaries.
        self.BIN_PATH = self.INSTALL_PATH + sep + 'bin'

        # Symbolic link installation path.
        self.SYMLINK = self.BIN_PATH + sep + 'relax'



        # The distribution files.
        if self.SYSTEM == 'Windows':
            self.BIN_FILE = 'relax-' + version + '.' + self.SYS + '.zip'
            self.SRC_FILE = 'relax-' + version + '.src.zip'
            self.DIST_TYPE = 'zip'
        else:
            self.BIN_FILE = 'relax-' + version + '.' + self.SYS + '.' + self.MACH + '.tar.bz2'
            self.SRC_FILE = 'relax-' + version + '.src.tar.bz2'
            self.DIST_TYPE = 'tar'


        # Documentation.
        ################

        # Documentation directory.
        self.DOCS_DIR = 'docs' + sep

        # LaTeX directory.
        self.LATEX_DIR = 'docs' + sep + 'latex' + sep



    def package(self, target, source, env):
        """Builder action for packaging the distribution archives."""

        # Print out.
        print
        print "#######################"
        print "# Packaging the files #"
        print "#######################\n\n"
        print "Creating the package distribution " + `env['DIST_FILE']` + ".\n"

        # Open the Zip distribution file.
        if self.DIST_TYPE == 'zip':
            archive = ZipFile(path.pardir + path.sep + env['DIST_FILE'], 'w', compression=8)

        # Open the Tar distribution file.
        elif self.DIST_TYPE == 'tar':
            if search('.bz2$', env['DIST_FILE']):
                archive = TarFile.bz2open(path.pardir + path.sep + env['DIST_FILE'], 'w')
            elif search('.gz$', env['DIST_FILE']):
                archive = TarFile.gzopen(path.pardir + path.sep + env['DIST_FILE'], 'w')
            else:
                archive = TarFile.open(path.pardir + path.sep + env['DIST_FILE'], 'w')

        # Base directory.
        base = getcwd() + sep

        # Walk through the directories.
        for root, dirs, files in walk(getcwd()):
            # Skip the subversion directories.
            if search("\.svn", root):
                continue

            # Add the files in the current directory to the archive.
            for i in xrange(len(files)):
                # Skip any '.sconsign' files, hidden files, byte-compiled '*.pyc' files, or binary objects '.o', '.os', 'obj', 'lib', and 'exp'.
                if search("\.sconsign", files[i]) or search("^\.", files[i]) or search("\.pyc$", files[i]) or search("\.o$", files[i]) or search("\.os$", files[i]) or search("\.obj$", files[i]) or search("\.lib$", files[i]) or search("\.exp$", files[i]):
                    continue

                # Create the file name (without the base directory).
                name = path.join(root, files[i])
                name = name[len(base):]
                print 'relax-' + version + path.sep + name

                # The archive file name.
                arcname = 'relax-' + version + path.sep + name

                # Zip archives.
                if self.DIST_TYPE == 'zip':
                    archive.write(filename=name, arcname=arcname)

                # Tar archives.
                if self.DIST_TYPE == 'tar':
                    archive.add(name=name, arcname=arcname)

        # Close the archive.
        archive.close()

        # Final print out.
        print "\n\n\n"


    def test_version(self, target, source, env):
        """Builder action for testing that the program version number has been set."""

        # Print out.
        print
        print "#######################################"
        print "# Checking the program version number #"
        print "#######################################\n\n"
        print "Version number: " + version + "\n"

        # Test.
        if version == "repository checkout":
            sys.stderr.write("The program version number has not been set.\n\n")
            sys.exit()

        # Final print out.
        print "\n\n\n"


    def uninstall(self, target, source, env):
        """relax deinstallation function (a Builder action)."""

        # Print out.
        ############

        print
        print "######################"
        print "# Uninstalling relax #"
        print "######################\n\n"
        print "Uninstalling the program relax from the directory " + `self.INSTALL_PATH` + "\n\n"


        # Tests.
        ########

        # Test that the installation path exists.
        if not access(self.INSTALL_PATH, F_OK):
            sys.stderr.write("Cannot uninstall relax, the installation path " + `self.INSTALL_PATH` + " does not exist.\n\n")
            return

        # Test if the binary directory already exists.
        if not access(self.BIN_PATH, F_OK):
            sys.stderr.write("Cannot uninstall relax, the directory " + `self.BIN_PATH` + " does not exist.\n\n")
            return

        # Test if the relax installation directory exists.
        if not access(self.RELAX_PATH, F_OK):
            sys.stderr.write("Cannot uninstall relax, the directory " + `self.RELAX_PATH` + " does not exist.\n\n")
            return

        # Test if the symlink exists.
        if self.symlink_flag:
            try:
                lstat(self.SYMLINK)
            except OSError:
                sys.stderr.write("Cannot uninstall relax, the file " + `self.SYMLINK` + " does not exist.\n\n")
                return


        # Uninstall.
        ############

        # Remove the symbolic link.
        if self.symlink_flag:
            print "\nRemoving the symbolic link " + `self.SYMLINK` + "."
            remove(self.SYMLINK)

        # Remove the directory.
        print "\nRemoving the entire directory " + `self.RELAX_PATH` + ".\n"
        for root, dirs, files in walk(self.RELAX_PATH, topdown=False):
            for file in files:
                remove(path.join(root, file))
            for file in dirs:
                rmdir(path.join(root, file))
        rmdir(self.RELAX_PATH)

        # Final print out.
        print "\n\n\n"



# Execute the main and manual classes.
Main()
