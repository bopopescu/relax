#! /usr/bin/python

###############################################################################
#                                                                             #
#                                    relax                                    #
#                                                                             #
#                   a program for relaxation data analysis                    #
#                                                                             #
#                             by Edward d'Auvergne                            #
#                                                                             #
###############################################################################
#                                                                             #
#                                   License                                   #
#                                                                             #
# relax, a program for relaxation data analysis.                              #
#                                                                             #
# Copyright (C) 2003, 2004  Edward d'Auvergne                                 #
#                                                                             #
# This program is free software; you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU Library General Public License for more details.                        #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program; if not, write to the Free Software                 #
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  #
#                                                                             #
###############################################################################


# Python modules.
import __builtin__
from os import F_OK, access, putenv
import profile
import pstats
from re import match
import sys

# Numeric.
try:
    import Numeric
except ImportError:
    sys.stderr.write("The dependency 'Numeric' has not been installed.\n")
    sys.exit()

# Scientific.
try:
    import Scientific
except ImportError:
    sys.stderr.write("The dependency 'Scientific' has not been installed.\n")
    sys.exit()

# Command line option parser.
try:
    from optparse import OptionParser
except ImportError:
    sys.stderr.write("The dependency 'Optik' has not been installed.\n")
    sys.exit()

# relax modules.
from data import Data
from errors import RelaxErrors
from file_ops import File_ops
from generic_fns.main import Generic
from prompt.interpreter import Interpreter
from specific_fns.main import Specific
from specific_fns.specific_setup import Specific_setup

sys.path.append(sys.path[0])
sys.path[0] = '.'
putenv('PDBVIEWER', 'vmd')


class Relax:
    def __init__(self):
        """The top level class for initialising the program."""

        # Set up the program internal errors.
        RelaxErrors()

        # Create a string to pass to the interpreter to print.
        self.set_intro_string()

        # Debugging option set by the command line argument '--debug', 0 = off, 1 = on.
        __builtin__.Debug = 0

        # The program data storage object.
        self.data = Data()

        # File operation functions.
        self.file_ops = File_ops(self)

        # Setup the specific setup object.
        self.specific_setup = Specific_setup(self)

        # Setup the object containing the generic functions.
        self.generic = Generic(self)

        # Setup the object containing the specific functions.
        self.specific = Specific(self)

        # Process the command line arguments and determine the relax mode.
        mode = self.arguments()

        # Run the interpreter for the prompt or script modes.
        if mode == 'prompt' or mode == 'script':
            self.interpreter = Interpreter(self)
            self.interpreter.run()

        # Test mode.
        if mode == 'test':
            self.test_mode()


    def arguments(self):
        """Function for processing the command line arguments."""

        # Parser object.
        parser = OptionParser(usage="usage: %prog [options] [script_file]", version="%prog unknown")

        # Recognised command line options.
        parser.add_option('-d', '--debug', action='store_true', dest='debug', default=0, help='enable debugging output')
        parser.add_option('-t', '--test', action='store_true', dest='test', default=0, help='run relax in test mode')
        parser.add_option('--thread', action='store_true', dest='thread', default=0, help='run relax in threading mode (a user should not invoke this mode)')
        parser.add_option('-l', '--log', action='store', type='string', dest='log', help='log relax output, not implemented yet')

        # Parse the options.
        (options, args) = parser.parse_args()

        # Debugging flag.
        if options.debug:
            __builtin__.Debug = 1

        # Logging.
        if options.log:
            parser.error("not implemented yet")

        # Number of positional arguements should only be 0 or 1.  1 should be the script file.
        if len(args) > 1:
            parser.error("incorrect number of arguments")

        # Script file.
        self.script_file = None
        if len(args) == 1:
            self.script_file = args[0]

            # Test if the script file exists.
            if not access(self.script_file, F_OK):
                parser.error("the script file " + `self.script_file` + " does not exist")


        # Determine the relax mode and test for mutually exclusive modes.
        #################################################################

        # Test mode.
        if options.test:
            # Make sure no script is supplied.
            if self.script_file:
                parser.error("a script should not be supplied in test mode")

            # Exclusive modes.
            if options.thread:
                parser.error("the relax modes test and thread are mutually exclusive")

            # Return the mode.
            return 'test'

        # Threaded mode.
        if options.thread:
            # Make sure no script is supplied.
            if self.script_file:
                parser.error("a script should not be supplied in test mode")

            # Exclusive modes.
            if options.test:
                parser.error("the relax modes thread and test are mutually exclusive")

            # Return the mode.
            return 'thread'

        # Script mode.
        if self.script_file:
            return 'script'

        # Prompt mode (default).
        return 'prompt'



    def set_intro_string(self):
        """Create the program introduction."""

        self.intro_string = """


                                            relax

                           a program for relaxation data analysis

                         Copyright (C) 2003, 2004 Edward d'Auvergne


This is free software which you are welcome to modify and redistribute under the conditions of the
GNU General Public License (GPL).  This program, including all modules, is licensed under the GPL
and comes with absolutely no warranty.  For details type 'GPL'.  Assistance in using this program
can be accessed by typing 'help'.
"""


    def test_mode(self):
        """Relax test mode code."""

        # Don't actually do anything.
        return


if __name__ == "__main__":
    # Change this flag to 1 for code profiling.
    profile_flag = 0

    if not profile_flag:
        Relax()
    else:
        def print_stats(stats):
            pstats.Stats(stats).sort_stats('time', 'name').print_stats()

        profile.Profile.print_stats = print_stats
        profile.run('Relax()')
