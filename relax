#! /usr/bin/python

###############################################################################
#                                                                             #
#                                    relax                                    #
#                                                                             #
#                 A program for NMR relaxation data analysis                  #
#                                                                             #
#                             by Edward d'Auvergne                            #
#                                                                             #
###############################################################################
#                                                                             #
#                                   License                                   #
#                                                                             #
# relax, a program for relaxation data analysis.                              #
#                                                                             #
# Copyright (C) 2003, 2004, 2005  Edward d'Auvergne                           #
#                                                                             #
# This program is free software; you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU Library General Public License for more details.                        #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program; if not, write to the Free Software                 #
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  #
#                                                                             #
###############################################################################


# Python modules.
import __builtin__
from os import F_OK, access, getpid, putenv
import profile
import pstats
from re import match
import sys

# Numeric.
try:
    import Numeric
except ImportError:
    sys.stderr.write("The dependency 'Numeric' has not been installed.\n")
    sys.exit()

# Scientific.
try:
    import Scientific
except ImportError:
    sys.stderr.write("The dependency 'Scientific' has not been installed.\n")
    sys.exit()

# Command line option parser.
try:
    from optparse import Option, OptionParser
except ImportError:
    sys.stderr.write("The dependency 'Optik' has not been installed.\n")
    sys.exit()

# relax modules.
from data import Data
from errors import RelaxErrors
from io import IO
from generic_fns.main import Generic
from prompt.gpl import gpl
from prompt.interpreter import Interpreter
from specific_fns.main import Specific
from specific_fns.specific_setup import Specific_setup
from thread_classes import Threading, ThreadData

sys.path.append(sys.path[0])
sys.path[0] = '.'
putenv('PDBVIEWER', 'vmd')


class Relax:
    def __init__(self):
        """The top level class for initialising the program."""

        # Get and store the PID of this process.
        self.pid = getpid()

        # Set up the program internal errors.
        RelaxErrors()

        # Debugging flag (default is off).
        __builtin__.Debug = 0

        # Set the program introduction string to nothing.
        self.intro_string = None

        # The program data storage object.
        self.data = Data()

        # The thread data storage object.
        self.thread_data = ThreadData()

        # File operation functions.
        self.IO = IO(self)

        # Setup the specific setup object.
        self.specific_setup = Specific_setup(self)

        # Setup the object containing the generic functions.
        self.generic = Generic(self)

        # Setup the object containing the specific functions.
        self.specific = Specific(self)

        # Setup the object containing the thread setup functions.
        self.threading = Threading(self)

        # Process the command line arguments and determine the relax mode.
        mode, log_file, tee_file = self.arguments()

        # Logging.
        if log_file and mode != 'thread':
            self.IO.log(log_file)

        # Tee.
        elif tee_file and mode != 'thread':
            self.IO.tee(tee_file)

        # Run the interpreter for the prompt or script modes.
        if mode == 'prompt' or mode == 'script':
            # Create a string to pass to the interpreter to print.
            self.set_intro_string()

            # Run the interpreter.
            self.interpreter = Interpreter(self)
            self.interpreter.run()

        # Threading mode.
        elif mode == 'thread':
            # Print the PID prior to IO redirection, and then flush the buffer to send it to the parent.
            print self.pid
            sys.stdout.flush()

            # Logging (silent IO redirection).
            if log_file:
                self.IO.log(log_file, print_flag=0)

            # Tee (silent IO redirection).
            elif tee_file:
                self.IO.tee(tee_file, print_flag=0)

            # Execute the script.
            self.threading.execute()

        # Test mode.
        elif mode == 'test':
            self.test_mode()

        # Licence mode.
        elif mode == 'licence':
            self.licence()


    def arguments(self):
        """Function for processing the command line arguments."""

        # Parser object.
        parser = RelaxParser(self, usage="usage: %prog [options] [script_file]", version="%prog unknown")

        # Recognised command line options.
        parser.add_option('-d', '--debug', action='store_true', dest='debug', default=0, help='enable debugging output')
        parser.add_option('-l', '--log', action='store', type='string', dest='log', help='log relax output to the file LOG_FILE', metavar='LOG_FILE')
        parser.add_option('-t', '--tee', action='store', type='string', dest='tee', help='tee relax output to sdtout and the file LOG_FILE', metavar='LOG_FILE')
        parser.add_option('--test', action='store_true', dest='test', default=0, help='run relax in test mode')
        parser.add_option('--thread', action='store_true', dest='thread', default=0, help='run relax in threading mode (a user should not invoke this mode)')
        parser.add_option('--licence', action='store_true', dest='licence', default=0, help='display the licence')

        # Parse the options.
        (options, args) = parser.parse_args()

        # Debugging flag.
        if options.debug:
            __builtin__.Debug = 1

        # Logging.
        if options.log:
            # Exclusive modes.
            if options.tee:
                parser.error("the logging and tee options cannot be set simultaneously")

            # The log file.
            log_file = options.log
        else:
            log_file = None

        # Tee.
        if options.tee:
            # Exclusive modes.
            if options.log:
                parser.error("the tee and logging options cannot be set simultaneously")

            # The tee file.
            tee_file = options.tee
        else:
            tee_file = None

        # Number of positional arguements should only be 0 or 1.  1 should be the script file.
        if len(args) > 1:
            parser.error("incorrect number of arguments")

        # Script file.
        self.script_file = None
        if len(args) == 1:
            self.script_file = args[0]

            # Test if the script file exists.
            if not access(self.script_file, F_OK):
                parser.error("the script file " + `self.script_file` + " does not exist")


        # Determine the relax mode and test for mutually exclusive modes.
        #################################################################

        # Test mode.
        if options.test:
            # Make sure no script is supplied.
            if self.script_file:
                parser.error("a script should not be supplied in test mode")

            # Exclusive modes.
            if options.thread:
                parser.error("the relax modes test and thread are mutually exclusive")
            elif options.licence:
                parser.error("the relax modes test and licence are mutually exclusive")

            # Set the mode.
            mode = 'test'

        # Threaded mode.
        elif options.thread:
            # Make sure a script is supplied.
            if not self.script_file:
                parser.error("in threaded mode, a script is required")

            # Exclusive modes.
            if options.test:
                parser.error("the relax modes thread and test are mutually exclusive")
            elif options.licence:
                parser.error("the relax modes thread and licence are mutually exclusive")

            # Set the mode.
            mode = 'thread'

        # Licence mode.
        elif options.licence:
            # Make sure no script is supplied.
            if self.script_file:
                parser.error("a script should not be supplied in test mode")

            # Exclusive modes.
            if options.test:
                parser.error("the relax modes licence and test are mutually exclusive")
            elif options.thread:
                parser.error("the relax modes licence and thread are mutually exclusive")

            # Set the mode.
            mode = 'licence'

        # Script mode.
        elif self.script_file:
            mode = 'script'

        # Prompt mode (default).
        else:
            mode = 'prompt'

        # Return.
        return mode, log_file, tee_file


    def licence(self):
        """Function for displaying the licence."""

        help(gpl)


    def set_intro_string(self):
        """Create the program introduction."""

        self.intro_string = """


                                            relax

                         A program for NMR relaxation data analysis

                      Copyright (C) 2003, 2004, 2005 Edward d'Auvergne


This is free software which you are welcome to modify and redistribute under the conditions of the
GNU General Public License (GPL).  This program, including all modules, is licensed under the GPL
and comes with absolutely no warranty.  For details type 'GPL'.  Assistance in using this program
can be accessed by typing 'help'.
"""


    def test_mode(self):
        """Relax test mode code."""

        # Don't actually do anything.
        return


class RelaxParser(OptionParser):
    def __init__(self, relax, usage=None, option_list=None, option_class=Option, version=None, conflict_handler="error", description=None, formatter=None, add_help_option=1, prog=None):
        """Subclassed OptionParser class with a replacement error function."""

        # Relax base class.
        self.relax = relax

        # Run the __init__ method of the OptionParser class.
        OptionParser.__init__(self, usage, option_list, option_class, version, conflict_handler, description, formatter, add_help_option, prog)


    def error(self, message):
        """Replacement error function."""

        # Usage message.
        self.print_usage(sys.stderr)

        # Raise a clean error.
        try:
            raise RelaxError, message
        except AllRelaxErrors, instance:
            sys.stderr.write(instance.__str__())

        # Exit.
        sys.exit()


if __name__ == "__main__":
    # Change this flag to 1 for code profiling.
    profile_flag = 0

    if not profile_flag:
        Relax()
    else:
        def print_stats(stats):
            pstats.Stats(stats).sort_stats('time', 'name').print_stats()

        profile.Profile.print_stats = print_stats
        profile.run('Relax()')
