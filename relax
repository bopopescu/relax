#! /usr/bin/env python

###############################################################################
#                                                                             #
#                                    relax                                    #
#                                                                             #
#               Protein dynamics by NMR relaxation data analysis              #
#                                                                             #
#                             by Edward d'Auvergne                            #
#                                                                             #
###############################################################################
#                                                                             #
#                                   Licence                                   #
#                                                                             #
# relax, a program for relaxation data analysis.                              #
#                                                                             #
# Copyright (C) 2001-2006  Edward d'Auvergne                                  #
#                                                                             #
# This program is free software; you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU Library General Public License for more details.                        #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program; if not, write to the Free Software                 #
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  #
#                                                                             #
###############################################################################


# Python modules.
import __builtin__
from os import F_OK, access, getpid, putenv
import platform
import profile
import pstats
from re import match
from string import split, strip
import sys
from warnings import warn

# Numeric.
try:
    import Numeric
except ImportError:
    sys.stderr.write("The dependency 'Numeric' has not been installed.\n")
    sys.exit()

# Scientific.
try:
    import Scientific
except ImportError:
    sys.stderr.write("The dependency 'Scientific' has not been installed.\n")
    sys.exit()

# Command line option parser.
try:
    from optparse import Option, OptionParser
except ImportError:
    sys.stderr.write("The dependency 'Optik' has not been installed.\n")
    sys.exit()

# relax modules.
from colour import Colour
from data.main import Data
from errors import RelaxErrors, RelaxWarnings
from io import IO
from generic_fns.main import Generic
from prompt.gpl import gpl
from prompt.interpreter import Interpreter
from specific_fns.main import Specific
from specific_fns.specific_setup import Specific_setup
from test_suite.runner import Test_suite_runner
from test_suite.unit_tests.unit_test_runner import Run_unit_tests
from thread_classes import Threading, ThreadData
import version

sys.path.append(sys.path[0])
sys.path[0] = '.'
putenv('PDBVIEWER', 'vmd')


class Relax:
    def __init__(self):
        """The top level class for initialising the program."""

        # relax version number.
        self.version = version.version

        # Get and store the PID of this process.
        self.pid = getpid()

        # Store the operating system name.
        self.platform = platform.uname()[0]

        # Set up the program internal errors.
        RelaxErrors(self)

        # Debugging flag (default is off).
        __builtin__.Debug = 0

        # Pedantic flag (default is off).
        __builtin__.Pedantic = 0

        # Set up the program internal errors.
        RelaxErrors(self)

        # Set the program introduction string to nothing.
        self.intro_string = None

        # The program data storage object.
        self.data = Data()

        # The thread data storage object.
        self.thread_data = ThreadData()

        # File operation functions.
        self.IO = IO(self)

        # Colour operations.
        self.colour = Colour()

        # Setup the specific setup object.
        self.specific_setup = Specific_setup(self)

        # Setup the object containing the generic functions.
        self.generic = Generic(self)

        # Setup the object containing the specific functions.
        self.specific = Specific(self)

        # Setup the object containing the thread setup functions.
        self.threading = Threading(self)

        # FIXME removed
        # Process the command line arguments and determine the relax mode.
        #mode, log_file, tee_file = self.arguments()

        # Initialise the warnings sytem.
        RelaxWarnings()
        __builtin__.warn = warn

    def run(self):

        #FIXME use self.mode all over
        mode = self.mode
        print mode

        # Show the version number and exit.
        if mode == 'version':
            print 'relax ' + self.version
            sys.exit()

        # FIXME threading
        # Logging.
        if self.log_file and mode != 'thread':
            self.IO.log(self.log_file)

        # Tee.
        elif self.tee_file and mode != 'thread':
            self.IO.tee(self.tee_file)

        # Run the interpreter for the prompt or script modes.
        if mode == 'prompt' or mode == 'script':
            # Create a string to pass to the interpreter to print.
            self.set_intro_string()

            # Run the interpreter.
            self.interpreter = Interpreter(self)
            self.interpreter.run()

        elif mode == 'slave':
            self.interpreter = Interpreter(self)
            self.dummy_mode=1
            self.interpreter.run()

        # FIXME no more threading
        # Threading mode.
#        elif mode == 'thread':
#            # Print the PID prior to IO redirection, and then flush the buffer to send it to the parent.
#            print self.pid
#            sys.stdout.flush()
#
#            # Logging (silent IO redirection).
#            if self.log_file:
#                self.IO.log(log_file, print_flag=0)
#
#            # Tee (silent IO redirection).
#            elif self.tee_file:
#                self.IO.tee(tee_file, print_flag=0)
#
#            # Execute the script.
#            self.threading.execute()

        # Execute the relax test suite
        elif mode == 'test suite':
            # Create a string to pass to the interpreter to print.
            self.set_intro_string()

            # Load the interpreter and turn intros on.
            self.interpreter = Interpreter(self)
            self.interpreter._on()

            # Run the tests.
            Test_suite_runner(self)

        # Execute the relax unit tests.
        elif mode == 'unit test':
            # Create a string to pass to the interpreter to print.
            self.set_intro_string()

            # Run the tests.
            runner = Run_unit_tests(root_path='test_suite/unit_tests')
            runner.run()

        # Test mode.
        elif mode == 'test':
            self.test_mode()

        # Licence mode.
        elif mode == 'licence':
            self.licence()


    def arguments(self,args):
        """Function for processing the command line arguments."""

        # Parser object.
        parser = RelaxParser(self, usage="usage: %prog [options] [script_file]")

        # Recognised command line options.
        parser.add_option('-d', '--debug', action='store_true', dest='debug', default=0, help='enable debugging output')
        parser.add_option('-l', '--log', action='store', type='string', dest='log', help='log relax output to the file LOG_FILE', metavar='LOG_FILE')
        parser.add_option('--licence', action='store_true', dest='licence', default=0, help='display the licence')
        parser.add_option('-t', '--tee', action='store', type='string', dest='tee', help='tee relax output to sdtout and the file LOG_FILE', metavar='LOG_FILE')
        parser.add_option('-p', '--pedantic', action='store_true', dest='pedantic', default=0, help='escalate all warnings to errors')
        parser.add_option('--test', action='store_true', dest='test', default=0, help='run relax in test mode')
        parser.add_option('--test-suite', action='store_true', dest='test_suite', default=0, help='execute the relax test suite')
        parser.add_option('--unit-test', action='store_true', dest='unit_test', default=0, help='execute the relax unit tests (part of the test suite)')
# FIXME remove threading
# threading dprecated
#        parser.add_option('--thread', action='store_true', dest='thread', default=0, help='run relax in threading mode (this mode should not be invoked by a user)')
        parser.add_option('-v', '--version', action='store_true', dest='version', default=0, help='show the version number and exit')
        parser.add_option('-m', '--multi', action='store', type='string', dest='multiprocessor', default='uni', help='set multi processor method')
        parser.add_option('-n', '--processors', action='store', type='int', dest='n_processors', default=1, help='set number of processors (may be ignored)')

        # Parse the options.
        (options, args) = parser.parse_args(args)

        # Debugging flag.
        if options.debug:
            __builtin__.Debug = 1

        # Pedantic flag.
        if options.pedantic:
            __builtin__.Pedantic = 1

        # Logging.
        if options.log:
            # Exclusive modes.
            if options.tee:
                parser.error("the logging and tee options cannot be set simultaneously")

            # The log file.
            self.log_file = options.log
        else:
            self.log_file = None

        # Tee.
        if options.tee:
            # Exclusive modes.
            if options.log:
                parser.error("the tee and logging options cannot be set simultaneously")

            # The tee file.
            self.tee_file = options.tee
        else:
            self.tee_file = None

        # Number of positional arguements should only be 0 or 1.  1 should be the script file.
        if len(args) > 1:
            parser.error("incorrect number of arguments")

        # Script file.
        self.script_file = None
        if len(args) == 1:
            self.script_file = args[0]

            # Test if the script file exists.
            if not access(self.script_file, F_OK):
                parser.error("the script file " + `self.script_file` + " does not exist")





        # Determine the relax mode and test for mutually exclusive modes.
        #################################################################

        # Show the version number.
        if options.version:
            mode = 'version'

        # Run the relax tests.
        elif options.test_suite or options.unit_test:
            # Make sure no script is supplied.
            if self.script_file:
                parser.error("a script should not be supplied when executing the test suite")

            # Exclusive modes.
            if options.test:
                parser.error("executing the relax test suite and running relax in test mode are mutually exclusive")
# FIXME: delete
#            elif options.thread:
#                parser.error("executing the relax test suite and running relax in thread mode are mutually exclusive")
            elif options.licence:
                parser.error("executing the relax test suite and running relax in licence mode are mutually exclusive")

            # Set the mode.
            if options.test_suite:
                mode = 'test suite'
            elif options.unit_test:
                mode = 'unit test'


        # Test mode.
        elif options.test:
            # Make sure no script is supplied.
            if self.script_file:
                parser.error("a script should not be supplied in test mode")

            # Exclusive modes.
            if options.test_suite or options.unit_test:
                parser.error("the relax test mode and executing the test suite are mutually exclusive")
# FIXME delete
#            elif options.thread:
#                parser.error("the relax modes test and thread are mutually exclusive")
            elif options.licence:
                parser.error("the relax modes test and licence are mutually exclusive")

            # Set the mode.
            mode = 'test'

        # FIXME threading deprecated
        # Threaded mode.
#        elif options.thread:
#            # Make sure a script is supplied.
#            if not self.script_file:
#                parser.error("in threaded mode, a script is required")
#
#            # Exclusive modes.
#            if options.test:
#                parser.error("the relax modes thread and test are mutually exclusive")
#            elif options.licence:
#                parser.error("the relax modes thread and licence are mutually exclusive")
#
#            # Set the mode.
#            mode = 'thread'

        # Licence mode.
        elif options.licence:
            # Make sure no script is supplied.
            if self.script_file:
                parser.error("a script should not be supplied in test mode")

            # Exclusive modes.
            if options.test_suite or options.unit_test:
                parser.error("the relax licence mode and executing the test suite are mutually exclusive")
            elif options.test:
                parser.error("the relax modes licence and test are mutually exclusive")
# FIXME delete
#            elif options.thread:
#                parser.error("the relax modes licence and thread are mutually exclusive")

            # Set the mode.
            mode = 'licence'



        # Script mode.
        elif self.script_file:
            #FIXME check for uniprocessor and n_processors
            self.multiprocessor_type = options.multiprocessor
            self.n_processors = options.n_processors
            mode = 'script'


        # Prompt mode (default).
        else:
            #FIXME check for uniprocessor and n_processors
            self.multiprocessor_type = options.multiprocessor
            self.n_processors = options.n_processors
            mode = 'prompt'

        # Return.

        # multi processor

        if options.multiprocessor == 'uni':
            self.multi_mode = 'uni'
        else:
            # Exclusive modes.
            if options.test_suite or options.unit_test:
                parser.error("the relax multi processor mode and executing the test suite are mutually exclusive")
            elif options.licence:
                parser.error("the relax multi processor multi processor and licence are mutually exclusive")

            self.multiprocessor_type = options.multiprocessor
            self.n_processors = options.n_processors

            #note will be changed to multi_master or multi_slave when multi_processor initialises
            self.multi_mode='multi'

        #FIXME: use self.mode throughout
        self.mode=mode



    def licence(self):
        """Function for displaying the licence."""

        help(gpl)


    def set_intro_string(self):
        """Create the program introduction."""

        # The width of the printout.
        if self.platform == 'Windows':
            width = 80
        else:
            width = 100

        # Some new lines.
        self.intro_string = '\n\n\n'

        # Program name and version.
        string = "relax " + self.version
        self.intro_string = self.intro_string + self.spacing(string, width) + '\n\n'

        # Program description.
        string = "Protein dynamics by NMR relaxation data analysis"
        self.intro_string = self.intro_string + self.spacing(string, width) + '\n\n'

        # Copyright printout.
        string = "Copyright (C) 2001-2006 Edward d'Auvergne"
        self.intro_string = self.intro_string + self.spacing(string, width) + '\n\n'

        # Program licence and help (80 characters wide).
        if width == 80:
            self.intro_string = self.intro_string + "This is free software which you are welcome to modify and redistribute under\n"
            self.intro_string = self.intro_string + "the conditions of the GNU General Public License (GPL).  This program,\n"
            self.intro_string = self.intro_string + "including all modules, is licensed under the GPL and comes with absolutely no\n"
            self.intro_string = self.intro_string + "warranty.  For details type 'GPL'.  Assistance in using this program can be\n"
            self.intro_string = self.intro_string + "accessed by typing 'help'.\n"

        # Program licence and help (100 characters wide).
        else:
            self.intro_string = self.intro_string + "This is free software which you are welcome to modify and redistribute under the conditions of the\n"
            self.intro_string = self.intro_string + "GNU General Public License (GPL).  This program, including all modules, is licensed under the GPL\n"
            self.intro_string = self.intro_string + "and comes with absolutely no warranty.  For details type 'GPL'.  Assistance in using this program\n"
            self.intro_string = self.intro_string + "can be accessed by typing 'help'.\n"


    def spacing(self, string, width=100):
        """Function for formatting the string to be centred to 100 spaces."""

        # Calculate the number of spaces needed.
        spaces = (width - len(string)) / 2

        # The new string.
        string = spaces * ' ' + string

        # Return the new string.
        return string


    def test_mode(self):
        """Relax test mode code."""

        # Don't actually do anything.
        return


class RelaxParser(OptionParser):
    def __init__(self, relax, usage=None, option_list=None, option_class=Option, version=None, conflict_handler="error", description=None, formatter=None, add_help_option=1, prog=None):
        """Subclassed OptionParser class with a replacement error function."""

        # Relax base class.
        self.relax = relax

        # Run the __init__ method of the OptionParser class.
        OptionParser.__init__(self, usage, option_list, option_class, version, conflict_handler, description, formatter, add_help_option, prog)


    def error(self, message):
        """Replacement error function."""

        # Usage message.
        self.print_usage(sys.stderr)

        # Raise a clean error.
        try:
            raise RelaxError, message
        except AllRelaxErrors, instance:
            sys.stderr.write(instance.__str__())

        # Exit.
        sys.exit()

# FIXME: code shared with unit testing framework not changed from unit tests version
# replace unit test version with this
def import_module(module_path, verbose=False):
    ''' import the python module named by module_path

        @type module_path: a string containing a dot separated module path
        @param module_path: a module path in python dot separated format
                            note: this currently doesn't support relative module
                            paths as defined by pep328 and python 2.5

        @type verbose: Boolean
        @param verbose: whether to report sucesses and failures for debugging

        @rtype:     list of class module instances or None
        @return:    the module path as a list of module instances or None
                    if the module path cannot be found in the python path

        '''

    module = None
    result = None

    #try:
    module = __import__(module_path,globals(),  locals(), [])
    if verbose:
        print 'loaded module %s' % module_path
    #except Exception, e:
    #    if verbose:
    #        print 'failed to load module_path %s' % module_path
    #        print 'exception:',e

    #FIXME: needs more failure checking
    if module != None:
        result = [module]
        components = module_path.split('.')
        for component in components[1:]:
            module = getattr(module, component)
            result.append(module)
    return result

#FIXME: mode not required should be an instance variable of relax?
#FIXME error checking for if module require not found
#FIXME move module loading to processor
#FIXME module loading code needs to be in a util module
def load_multiprocessor(relax_instance):

    processor_name = relax_instance.multiprocessor_type + '_processor'
    class_name= processor_name[0].upper() + processor_name[1:]
    module_path = '.'.join(('multi',processor_name))


    modules = import_module(module_path)
    #print modules

    if hasattr(modules[-1],class_name):
        clazz =  getattr(modules[-1], class_name)
    else:
        raise RelaxError("can't load class %s from module %s" % (class_name,module_path))

    object = clazz(relax_instance)
    relax_instance.processor =  object
    return object

if __name__ == "__main__":
    #import multi.uni_processor
    for elem in  sys.modules:
        if elem == 'multi.uni_processor':
            print 'found',elem
    # Change this flag to 1 for code profiling.
    profile_flag = 0

    if not profile_flag:
        relax_instance = Relax()
        mode=relax_instance.arguments(sys.argv[1:])
        multi_processor = load_multiprocessor(relax_instance)
        multi_processor.run()

    else:
        def print_stats(stats, status=0):
            pstats.Stats(stats).sort_stats('time', 'name').print_stats()
        #FIXME: profiling won't work with multi processors.
        profile.Profile.print_stats = print_stats
        profile.run('Relax()')


