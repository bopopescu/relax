###############################################################################
#                                                                             #
# Copyright (C) 2004-2005, 2009 Edward d'Auvergne                             #
#                                                                             #
# This file is part of the program relax.                                     #
#                                                                             #
# relax is free software; you can redistribute it and/or modify               #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# relax is distributed in the hope that it will be useful,                    #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with relax; if not, write to the Free Software                        #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   #
#                                                                             #
###############################################################################

# Module docstring.
"""Module containing the Monte Carlo simulation 'monte_carlo' user function class."""
__docformat__ = 'plaintext'

# Python module imports.
import sys

# relax module imports.
from base_class import User_fn_class
import check
from generic_fns import monte_carlo


class Monte_carlo(User_fn_class):
    """Class containing the functions for Monte Carlo and related simulations."""

    def create_data(self, method='back_calc'):
        """Function for creating simulation data.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        method:  The simulation method.


        Description
        ~~~~~~~~~~~

        The method argument can either be set to 'back_calc' or 'direct', the choice of which
        determines the simulation type.  If the values or parameters are calculated rather than
        minimised, this option will have no effect, hence, 'back_calc' and 'direct' are identical.

        For error analysis, the method argument should be set to 'back_calc' which will result in
        proper Monte Carlo simulations.  The data used for each simulation is back calculated from
        the minimised model parameters and is randomised using Gaussian noise where the standard
        deviation is from the original error set.  When the method is set to 'back_calc', this
        function should only be called after the model is fully minimised.

        The simulation type can be changed by setting the method argument to 'direct'.  This will
        result in simulations which cannot be used in error analysis and which are no longer Monte
        Carlo simulations.  However, these simulations are required for certain model selection
        techniques (see the documentation for the model selection function for details), and can be
        used for other purposes.  Rather than the data being back calculated from the fitted model
        parameters, the data is generated by taking the original data and randomising using Gaussian
        noise with the standard deviations set to the original error set.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.create_data("
            text = text + "method=" + repr(method) + ")"
            print(text)

        # The argument checks.
        check.is_str(method, 'method')

        # Execute the functional code.
        monte_carlo.create_data(method=method)


    def error_analysis(self, prune=0.0):
        """Function for calculating parameter errors from the Monte Carlo simulations.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        prune:  Legacy argument corresponding to 'trim' in Art Palmer's Modelfree program.


        Description
        ~~~~~~~~~~~

        Parameter errors are calculated as the standard deviation of the distribution of parameter
        values.  This function should never be used if parameter values are obtained by minimisation
        and the simulation data are generated using the method 'direct'.  The reason is because only
        true Monte Carlo simulations can give the true parameter errors.

        The prune argument is legacy code which corresponds to the 'trim' option in Art Palmer's
        Modelfree program.  To remove failed simulations, the eliminate function should be used
        prior to this function.  Eliminating the simulations specifically identifies and removes the
        failed simulations whereas the prune argument will only, in a few cases, positively identify
        failed simulations but only if severe parameter limits have been imposed.  Most failed
        models will pass through the pruning process and hence cause a catastrophic increase in the
        parameter errors.  If the argument must be used, the following must be taken into account.
        If the values or parameters are calculated rather than minimised, the prune argument must be
        set to zero.  The value of this argument is proportional to the number of simulations
        removed prior to error calculation.  If prune is set to 0.0, all simulations are used for
        calculating errors, whereas a value of 1.0 excludes all data.  In almost all cases prune
        must be set to zero, any value greater than zero will result in an underestimation of the
        error values.  If a value is supplied, the lower and upper tails of the distribution of
        chi-squared values will be excluded from the error calculation.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.error_analysis("
            text = text + "prune=" + repr(prune) + ")"
            print(text)

        # The argument checks.
        check.is_num(prune, 'prune')

        # Execute the functional code.
        monte_carlo.error_analysis(prune=prune)


    def initial_values(self):
        """Function for setting the initial simulation parameter values.

        Description
        ~~~~~~~~~~~

        This function only effects where minimisation occurs and can therefore be skipped if the
        values or parameters are calculated rather than minimised.  However, if accidentally run in
        this case, the results will be unaffected.  It should only be called after the model or run
        is fully minimised.  Once called, the functions 'grid_search' and 'minimise' will only
        effect the simulations and not the model parameters.

        The initial values of the parameters for each simulation is set to the minimised parameters
        of the model.  A grid search can be undertaken for each simulation instead, although this
        is computationally expensive and unnecessary.  The minimisation function should be executed
        for a second time after running this function.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.initial_values()"
            print(text)

        # Execute the functional code.
        monte_carlo.initial_values()


    def off(self):
        """Function for turning simulations off."""

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.off()"
            print(text)

        # Execute the functional code.
        monte_carlo.off()


    def on(self):
        """Function for turning simulations on."""

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.on()"
            print(text)

        # Execute the functional code.
        monte_carlo.on()


    def setup(self, number=500):
        """Function for setting up Monte Carlo simulations.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        number:  The number of Monte Carlo simulations.


        Description
        ~~~~~~~~~~~

        This function must be called prior to any of the other Monte Carlo functions.  The effect is
        that the number of simulations will be set and that simulations will be turned on.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.setup("
            text = text + "number=" + repr(number) + ")"
            print(text)

        # The argument checks.
        check.is_int(number, 'number of Monte Carlo simulations')

        # Execute the functional code.
        monte_carlo.setup(number=number)



    # Modify all docstrings.
    ########################

    __description__ = """
        Monte Carlo Simulation Overview
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        For proper error analysis using Monte Carlo simulations, a sequence of function calls is
        required for running the various simulation components.  The steps necessary for
        implementing Monte Carlo simulations are:

        1.  The measured data set together with the corresponding error set should be loaded into
        relax.

        2.  Either minimisation is used to optimise the parameters of the chosen model, or a
        calculation is run.

        3.  To initialise and turn on Monte Carlo simulations, the number of simulations, n, needs
        to be set.

        4.  The simulation data needs to be created either by back calculation from the fully
        minimised model parameters from step 2 or by direct calculation when values are calculated
        rather than minimised.  The error set is used to randomise each simulation data set by
        assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo
        simulation.

        5.  Prior to minimisation of the parameters of each simulation, initial parameter estimates
        are required.  These are taken as the optimised model parameters.  An alternative is to use
        a grid search for each simulation to generate initial estimates, however this is extremely
        computationally expensive.  For the case where values are calculated rather than minimised,
        this step should be skipped (although the results will be unaffected if this is accidentally
        run).

        6.  Each simulation requires minimisation or calculation.  The same techniques as used in
        step 2, excluding the grid search when minimising, should be used for the simulations.

        7.  Failed simulations are removed using the techniques of model elimination.

        8.  The model parameter errors are calculated from the distribution of simulation
        parameters.


        Monte Carlo simulations can be turned on or off using functions within this class.  Once the
        function for setting up simulations has been called, simulations will be turned on.  The
        effect of having simulations turned on is that the functions used for minimisation (grid
        search, minimise, etc) or calculation will only affect the simulation parameters and not the
        model parameters.  By subsequently turning simulations off using the appropriate function,
        the functions used in minimisation will affect the model parameters and not the simulation
        parameters.


        An example, for model-free analysis, which includes only the functions required for
        implementing the above steps is:

        relax> grid_search(inc=11)                                       # Step 2.
        relax> minimise('newton')                                        # Step 2.
        relax> monte_carlo.setup(number=500)                             # Step 3.
        relax> monte_carlo.create_data(method='back_calc')               # Step 4.
        relax> monte_carlo.initial_values()                              # Step 5.
        relax> minimise('newton')                                        # Step 6.
        relax> eliminate()                                               # Step 7.
        relax> monte_carlo.error_analysis()                              # Step 8.

        An example for reduced spectral density mapping is:

        relax> calc()                                                    # Step 2.
        relax> monte_carlo.setup(number=500)                             # Step 3.
        relax> monte_carlo.create_data(method='back_calc')               # Step 4.
        relax> calc()                                                    # Step 6.
        relax> monte_carlo.error_analysis()                              # Step 8.
    """

    create_data.__doc__ = create_data.__doc__ + "\n\n" + __description__
    error_analysis.__doc__ = error_analysis.__doc__ + "\n\n" + __description__
    initial_values.__doc__ = initial_values.__doc__ + "\n\n" + __description__
    off.__doc__ = off.__doc__ + "\n\n" + __description__
    on.__doc__ = on.__doc__ + "\n\n" + __description__
    setup.__doc__ = setup.__doc__ + "\n\n" + __description__
