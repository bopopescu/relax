###############################################################################
#                                                                             #
# Copyright (C) 2004 Edward d'Auvergne                                        #
#                                                                             #
# This file is part of the program relax.                                     #
#                                                                             #
# relax is free software; you can redistribute it and/or modify               #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation; either version 2 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# relax is distributed in the hope that it will be useful,                    #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with relax; if not, write to the Free Software                        #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   #
#                                                                             #
###############################################################################

import sys

import help


class Monte_carlo:
    def __init__(self, relax):
        # Help.
        self.__relax_help__ = \
        """Class containing the functions for Monte Carlo and related simulations."""

        # Add the generic help string.
        self.__relax_help__ = self.__relax_help__ + "\n" + help.relax_class_help

        # Place relax in the class namespace.
        self.__relax__ = relax


    def create_data(self, run=None, method='back_calc'):
        """Function for creating simulation data.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        run:  The name of the run.

        method:  The simulation method.


        Description
        ~~~~~~~~~~~

        The method argument can either be set to 'back_calc' or 'direct', the choice of which
        determines the simulation type.

        For error analysis, the method argument should be set to 'back_calc' which will result in
        proper Monte Carlo simulations.  The data used for each simulation is back calculated from
        the minimised model parameters and is randomised using Gaussian noise where the standard
        deviation is from the original error set.  When the method is set to 'back_calc', this
        function should only be called after the model or run is fully minimised.

        The simulation type can be changed by setting the method argument to 'direct'.  This will
        result in simulations which cannot be used in error analysis and which are no longer Monte
        Carlo simulations.  However, these simulations are required for certain model selection
        techniques (see the documentation for the model selection function for details), and can be
        used for other purposes.  Rather than the data being back calculated from the fitted model
        parameters, the data is generated by taking the original data and randomising using Gaussian
        noise with the standard deviations set to the original error set.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.create_data("
            text = text + "run=" + `run`
            text = text + ", method=" + `method` + ")"
            print text

        # The run argument.
        if type(run) != str:
            raise RelaxStrError, ('run', run)

        # The method argument.
        if type(method) != str:
            raise RelaxStrError, ('method', method)

        # Execute the functional code.
        self.__relax__.generic.monte_carlo.create_data(run=run, method=method)


    def error_analysis(self, run=None, prune=0):
        """Function for calculating parameter errors from the Monte Carlo simulations.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        run:  The name of the run.

        prune:  The proportion of the simulations to prune for the calculation of parameter errors.


        Description
        ~~~~~~~~~~~

        Parameter errors are calculated as the standard deviation of the distribution of parameter
        values.  This function will not work if the simulation data was generated using the method
        'direct' as only true Monte Carlo simulations can give true errors.

        The prune argument is equivalent to Art Palmer's 'trim' parameter in Modelfree.  The
        argument value is the proportion of simulations removed prior to error calculation.  If
        prune is set to 0, all simulations are used for calculating errors, whereas a value of 1
        excludes all data.  In almost all cases prune must be set to zero, any value greater than
        zero will result in an underestimation of the error values.  If a value is supplied, then
        the lower and upper tails (of the distribution of chi-squared values) will be excluded from
        the error calculation.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.error_analysis("
            text = text + "run=" + `run`
            text = text + ", prune=" + `prune` + ")"
            print text

        # The run argument.
        if type(run) != str:
            raise RelaxStrError, ('run', run)

        # The prune argument.
        if type(prune) != int and type(prune) != float:
            raise RelaxNumError, ('prune', prune)

        # Execute the functional code.
        self.__relax__.generic.monte_carlo.error_analysis(run=run, prune=prune)


    def initial_values(self, run=None):
        """Function for setting the initial simulation parameter values.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        run:  The name of the run.

        number:  The number of Monte Carlo simulations.

        prune:  The proportion of the simulations to prune for the calculation of parameter errors.

        method:  The simulation method.


        Description
        ~~~~~~~~~~~

        This function should only be called after the model or run is fully minimised.  Once called,
        the functions 'grid_search' and 'minimise' will only effect the simulations and not the
        model parameters.

        The initial values of the parameters for each simulation is set to the minimised parameters
        of the model.  A grid search can be undertaken for each simulation instead, although this
        is computationally expensive and unnecessary.  The minimisation function should be executed
        for a second time after running this function.

        The prune argument is equivalent to Art Palmer's 'trim' parameter in Modelfree.  The
        argument value is the proportion of simulations removed prior to error calculation.  If
        prune is set to 0, all simulations are used for calculating errors, whereas a value of 1
        excludes all data.  In almost all cases prune must be set to zero, any value greater than
        zero will result in an underestimation of the error values.  If a value is supplied, then
        the lower and upper tails (of the distribution of chi-squared values) will be excluded from
        the error calculation.

        For error analysis, the method argument should be set to 'mc' which will result in proper
        Monte Carlo simulations.  The data used for each simulation is back calculated from the
        minimised model parameters and is randomised using Gaussian noise where the standard
        deviation is the original data error.

        The behaviour of this function can be modified by setting the method argument to 'random'.
        This is required for certain model selection techniques (see the documentation for the model
        selection function for details), and can be used for other purposes.  Two major differences
        occur after setting this argument.  The first is that errors are no longer calculated from
        the simulations.  The second is that the data used in the simulation is not back calculated
        from the fitted model parameters.  The data is simply the original data randomised using
        Gaussian noise with the standard deviations set to the original data errors.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.initial_values("
            text = text + "run=" + `run` + ")"
            print text

        # The run argument.
        if type(run) != str:
            raise RelaxStrError, ('run', run)

        # Execute the functional code.
        self.__relax__.generic.monte_carlo.initial_values(run=run)


    def off(self, run=None):
        """Function for turning simulations off.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        run:  The name of the run.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.off("
            text = text + "run=" + `run` + ")"
            print text

        # The run argument.
        if type(run) != str:
            raise RelaxStrError, ('run', run)

        # Execute the functional code.
        self.__relax__.generic.monte_carlo.off(run=run)


    def on(self, run=None):
        """Function for turning simulations on.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        run:  The name of the run.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.on("
            text = text + "run=" + `run` + ")"
            print text

        # The run argument.
        if type(run) != str:
            raise RelaxStrError, ('run', run)

        # Execute the functional code.
        self.__relax__.generic.monte_carlo.on(run=run)


    def setup(self, run=None, number=500):
        """Function for setting up Monte Carlo simulations.

        Keyword Arguments
        ~~~~~~~~~~~~~~~~~

        run:  The name of the run.

        number:  The number of Monte Carlo simulations.


        Description
        ~~~~~~~~~~~

        This function must be called prior to any of the other Monte Carlo functions.  The effect is
        that the number of simulations for the given run will be set and that simulations will be
        turned on.
        """

        # Function intro text.
        if self.__relax__.interpreter.intro:
            text = sys.ps3 + "monte_carlo.setup("
            text = text + "run=" + `run`
            text = text + ", number=" + `number` + ")"
            print text

        # The run argument.
        if type(run) != str:
            raise RelaxStrError, ('run', run)

        # The number of simulations.
        if type(number) != int:
            raise RelaxIntError, ('number', number)

        # Execute the functional code.
        self.__relax__.generic.monte_carlo.setup(run=run, number=number)



    # Modify all docstrings.
    ########################

    __description__ = """
        Monte Carlo Simulation Overview
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        For proper error analysis using Monte Carlo simulations, a sequence of function calls is
        required for running the various simulation components.  The steps necessary for
        implementing Monte Carlo simulations are:

        1.  The measured data set together with the corresponding error set should be loaded into
        relax.

        2.  Chi-squared minimisation is used to optimise the parameters of the chosen model.

        3.  To initialise and turn on Monte Carlo simulations, the number of simulations, n, needs
        to be set.

        4.  The simulation data needs to be created by back calculation from the fully minimised
        model parameters from step 2.  The error set is used to randomise each simulation data set
        by assuming Gaussian errors.  This creates a synthetic data set for each Monte Carlo
        simulation.

        5.  Prior to minimisation of the parameters of each simulation, initial parameter estimates
        are required.  These are taken as the optimised model parameters.  An alternative is to use
        a grid search for each simulation to generate initial estimates, however this is extremely
        computationally expensive.

        6.  Each simulation requires minimisation.  The same techniques as used in step 2, excluding
        the grid search, should be used for the simulations.

        7.  The model parameter errors are calculated from the distribution of simulation
        parameters.


        Monte Carlo simulations can be turned on or off using functions within this class.  Once the
        function for setting up simulations has been called, simulations will be turned on.  The
        effect of having simulations turned on is that the functions used for minimisation (grid
        search, minimise, etc) will only affect the simulation parameters and not the model
        parameters.  By subsequently turning simulations off using the appropriate function, the
        functions used in minimisation will affect the model parameters and not the simulation
        parameters.


        An example, for model-free analysis, which includes solely the functions required for
        implementing the above steps is:

        relax> grid_search('m1', inc=11)                             # Step 2.
        relax> minimise('newton', run='m1')                          # Step 2.
        relax> monte_carlo.setup('m1', number=500)                   # Step 3.
        relax> monte_carlo.create_data('m1', method='back_calc')     # Step 4.
        relax> monte_carlo.initial_values('m1')                      # Step 5.
        relax> minimise('newton', run='m1')                          # Step 6.
        relax> monte_carlo.error_analysis('m1')                      # Step 7.
    """

    create_data.__doc__ = create_data.__doc__ + "\n\n" + __description__
    error_analysis.__doc__ = error_analysis.__doc__ + "\n\n" + __description__
    initial_values.__doc__ = initial_values.__doc__ + "\n\n" + __description__
    off.__doc__ = off.__doc__ + "\n\n" + __description__
    on.__doc__ = on.__doc__ + "\n\n" + __description__
    setup.__doc__ = setup.__doc__ + "\n\n" + __description__
